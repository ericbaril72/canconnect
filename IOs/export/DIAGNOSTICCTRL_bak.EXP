
(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/2- CONFIG AND DIAGNOSTIC' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM DiagnosticCtrl
VAR CONSTANT
	MaxLines : BYTE := 4;
END_VAR
VAR
	B_Init : BOOL := TRUE;
	MEMORY_RETAIN_PARAM1: MEMORY_RETAIN_PARAM;

	F1 : BOOL;			(* Key *)
	F2 : BOOL;			(* Key *)
	F3 : BOOL;			(* Key *)
	F4 : BOOL;			(* Key *)
	F5 : BOOL;			(* Key *)
	F6 : BOOL;			(* Key *)
	F7: BOOL;			(* Key *)
	F8 : BOOL;			(* Key *)
	KEY_OK: BOOL;	(* Key *)
	KEY_ESC: BOOL;	(* Key *)
	KEY_UP: BOOL;	(* Key *)
	KEY_DOWN: BOOL;	(* Key *)
	KEY_LEFT: BOOL;	(* Key *)
	KEY_RIGHT: BOOL;	(* Key *)

	RT_F1: KeyDebounce;
	RT_F2: KeyDebounce;
	RT_F3: KeyDebounce;
	RT_F4: KeyDebounce;
	RT_F5: KeyDebounce;
	RT_F6: KeyDebounce;
	RT_F7: KeyDebounce;
	RT_F8: KeyDebounce;
	RT_KEY_OK: KeyDebounce;
	RT_KEY_ESC: KeyDebounce;
	RT_KEY_LEFT: KeyDebounce;
	RT_KEY_RIGHT: KeyDebounce;
	RT_KEY_UP: KeyDebounce;
	RT_KEY_DOWN: KeyDebounce;

	OperationsEnable : ARRAY [0..25] OF BOOL;
	ConfigEnable : ARRAY [0..70] OF BOOL;

	OperationsTextList : ARRAY [0..25] OF WORD;
	DiagnosticTextList : ARRAY [0..7] OF WORD;
	ConfigTextList : ARRAY [0..70] OF WORD;
	FaultLogTextList : ARRAY [0..4] OF WORD;
	InformationTextList : ARRAY [0..4] OF WORD;

	Index : WORD;
	SelectedLine : BYTE := 0;
	ScanIndex : ARRAY [0..400] OF WORD;
	ScanIndexPointer : WORD := 0;
	ScanIndexPointer2 : WORD;
	ScanIndexMax : WORD;

	OperationsSelectedLine: WORD;
	DiagnosticSelectedLine: BYTE;
	DiagnosticDisplayLine : BYTE;
	ConfigSelectedLine: WORD;
	FaultLogSelectedLine: BYTE;
	FaultLogDisplayLine : BYTE;
	BY_FaultLogEntriesCount: BYTE;			(* Number of log entries *)
	InformationSelectedLine: BYTE;
	InformationDisplayLine : BYTE;

	TONInitDelay: TON;
	TONInitDelay2: TON;
	T_StartTime: TIME;
	W_ElapsedTime : WORD;
	B_HoldKeyUp : BOOL;
	B_HoldKeyDown : BOOL;
	R_DriveSpeed : WORD;
	R_DriveSpeed1 : REAL;
	R_DriveSpeed2 : REAL;
	R_DriveSpeed3 : REAL;
	R_DriveSpeed4 : REAL;
	R_DriveSpeed5 : REAL;
	BY_DigitSelected: BYTE :=1;
	B_SkipLine : BOOL;
	B_TmpVal : BOOL;
	W_SelectedIndex : WORD;
	W_DisplayedIndex : ARRAY [0..3] OF WORD;
	BY_CurrentLine : BYTE;
	B_SpecialMenu: BOOL;
	B_ASDLoaded : BOOL;
	BY_LoadTestCode : BYTE;
	B_LoadTestOK: BOOL;
	DW_LoadTestCycle: DWORD;
	RT_Cycles: R_TRIG;
	BY_OptionCode: BYTE;
	BY_F3Code: BYTE;
	B_F3SpecialBypass: BOOL;
	B_OptionBypass: BOOL;
	BY_Mode: BYTE;
END_VAR
(* @END_DECLARATION := '0' *)
MEMORY_RETAIN_PARAM1(ENABLE:=TRUE , LEN:= 4096 , MODE:=3 );

IF B_Init THEN
	IO_List;							(* Setup config for all inputs/outputs *)
	DiagnosticCheck_List;			(* Setup Name/Description for all Faults*)
	ShortOpenDetect();				(*Configure CR0032 Short Open Detect*)
	R_Distance := DW_Odometer;

	(*Setup Name of All Menu*)
	OperationsTextList[0] := TL_BridgeUpDownSlow;
	OperationsTextList[1] := TL_BridgeUpDownFast;
	OperationsTextList[2] := TL_ElevatorUpDownSlow;
	OperationsTextList[3] := TL_ElevatorUpDownFast;

	OperationsTextList[6] := TL_BridgeTransfer;
	OperationsTextList[7] := TL_FrontElevatorTransfer;
	OperationsTextList[8] := TL_RearElevatorTransfer;
	OperationsTextList[9] := TL_ElevatorRearRotate;
	OperationsTextList[10] := TL_ElevatorCenterRotate;

	OperationsTextList[12] := TL_ElevatorLeftGuideDown;
	OperationsTextList[13] := TL_ElevatorRightGuideDown;
	OperationsTextList[14] := TL_ElevatorRearPalletStopDown;

	OperationsTextList[17] := TL_HighDemand;
	OperationsTextList[18] := TL_SupercapsDischarge;

	DiagnosticTextList[0] := TL_InputsAnalog;
	DiagnosticTextList[1] := TL_InputsDigital;
	DiagnosticTextList[2] := TL_OutputsAnalog;
	DiagnosticTextList[3] := TL_OutputsDigital;
	DiagnosticTextList[4] := TL_Network;

	ConfigTextList[0] := TL_SerialNumber;
	IF B_OPT_929 THEN
		ConfigTextList[1] := TL_BridgeUpFastSpeed;
		ConfigTextList[2] := TL_BridgeDownFastSpeed;
		ConfigTextList[3] := TL_BridgeUpSlowSpeed;
		ConfigTextList[4] := TL_BridgeDownSlowSpeed;
	ELSE (*838*)
		ConfigTextList[3] := TL_BridgeSlowSpeed;
		ConfigTextList[4] := TL_BridgeFastSpeed;
	END_IF
	ConfigTextList[5] := TL_ElevatorUpFastSpeed;
	ConfigTextList[6] := TL_ElevatorDownFastSpeed;
	ConfigTextList[7] := TL_ElevatorUpSlowSpeed;
	ConfigTextList[8] := TL_ElevatorDownSlowSpeed;
	ConfigTextList[9] := TL_ChargePressureSetup;

	ConfigTextList[11] := TL_BridgeForwardReverseSpeed;
	ConfigTextList[12] := TL_FrontElevatorForwardReverseSpeed;
	ConfigTextList[13] := TL_RearElevatorForwardReverseSpeed;
	ConfigTextList[14] := TL_BridgeSideShiftSpeed;
	ConfigTextList[15] := TL_FrontElevatorSideShiftSpeed;
	ConfigTextList[16] := TL_RearElevatorSideShiftSpeed;
	ConfigTextList[17] := TL_ElevatorCenterRotateSpeed;
	ConfigTextList[18] := TL_ElevatorRearRotateSpeed;
	ConfigTextList[19] := TL_MinimumTransferPressure;

	ConfigTextList[23] := TL_DriveCreepSpeed;
	ConfigTextList[24] := TL_DriveASDSpeed;

	ConfigTextList[26] := TL_DriveMaxSpeed;

	ConfigTextList[29] := TL_BridgeTransferThreshold;
	ConfigTextList[30] := TL_ElevatorUpThreshold;
	ConfigTextList[31] := TL_FrontElevatorTransferThreshold;
	ConfigTextList[32] := TL_RearElevatorTransferThreshold;

	ConfigTextList[35] := TL_ElevatorDownThreshold;

	ConfigTextList[37] := TL_RegenControlThreshold;

	ConfigTextList[40] := TL_CameraAdjust;

	ConfigTextList[42] := TL_ForceMode;
	ConfigTextList[43] := TL_SV90Bypass;
	ConfigTextList[44] := TL_SideRollerBypass;
	ConfigTextList[45] := TL_MaximumBatteryCurrent;
	ConfigTextList[46] := TL_StateOfChargeReset;

	ConfigTextList[48] := TL_PumpMotorEnable;
	ConfigTextList[49] := TL_TractionMotorEnable;
	ConfigTextList[50] := TL_RegenMotorEnable;
	ConfigTextList[51] := TL_AutomaticShutdownTime;

	ConfigTextList[61] := TL_HourmeterAdjust;

	FaultLogTextList[0] := TL_DisplayFaults;
	FaultLogTextList[1] := TL_MotorFaults;
	FaultLogTextList[2] := TL_ASDEventLog;
	FaultLogTextList[3] := TL_EraseAllEntries;

	InformationTextList[0] := TL_Motors;
	InformationTextList[1] := TL_SystemStatus;
	InformationTextList[2] := TL_History;
	InformationTextList[3] := TL_Version;
END_IF

(* Operation menus enable/disable *)
(*'BRIDGE LIFT SLOW'*)
OperationsEnable[0] := TRUE;
(*'BRIDGE LIFT FAST'*)
OperationsEnable[1] := TRUE;
(*'ELEVATOR LIFT SLOW'*)
OperationsEnable[2] := TRUE;
(*'ELEVATOR LIFT FAST'*)
OperationsEnable[3] := TRUE;
(*'BRIDGE TRANSFERS'*)
OperationsEnable[6] := TRUE;
(*'ELEV FRONT TRANSFERS'*)
OperationsEnable[7] := TRUE;
(*'ELEV REAR TRANSFERS'*)
OperationsEnable[8] := TRUE;
(*'ELEV REAR ROTATE'*)
OperationsEnable[9] := TRUE;
(*'ELEV CENTER ROTATE'*)
OperationsEnable[10] := OPT_ElevatorDualRotate;
(*'LEFT SIDE GUIDE DOWN'*)
OperationsEnable[12] := TRUE;
(*'RIGHT SIDE GUIDE DOWN'*)
OperationsEnable[13] := TRUE;
(*'REAR ELEV STOP DOWN'*)
OperationsEnable[14] := TRUE;
(*HIGH DEMAND'*)
OperationsEnable[17] := TRUE;
(*SUPERCAPS DISCHARGE*)
OperationsEnable[18] := OPT_DCDCSystem AND OPT_LeadAcidBattery;

(* Configuration menus enable/disable *)
(* Must match ConfigTextList array *)

(*UNIT SERIAL NUMBER*)
ConfigEnable[0] := B_SpecialMenu;
(*BRIDGE UP FAST SPEED*)
ConfigEnable[1] := B_OPT_929;
(*BRIDGE DOWN FAST SPEED*)
ConfigEnable[2] := B_OPT_929;
(*'BRIDGE SLOW SPEED 838 // BRIDGE UP SLOW SPEED 929',*)
ConfigEnable[3] := TRUE;
(*'BRIDGE FAST SPEED 838', // BRIDGE DOWN SLOW SPEED 929*)
ConfigEnable[4] := TRUE;
(*'ELEV UP SPEED',*)
ConfigEnable[5] := TRUE;
(*'ELEV DOWN SPEED',*)
ConfigEnable[6] := TRUE;
(*'ELEV UP SLOW SPEED',*)
ConfigEnable[7] := TRUE;
(*'ELEV DOWN SLOW SPEED',*)
ConfigEnable[8] := TRUE;
(*'CHARGE PRESSURE SETUP',*)
ConfigEnable[9] := B_SpecialMenu;
(*'BRIDGE FWD/REV SPEED',*)
ConfigEnable[11] := TRUE;
(*'ELEV FRONT SPEED',*)
ConfigEnable[12] := TRUE;
(*'ELEV REAR SPEED',*)
ConfigEnable[13] := TRUE;
(*'BRIDGE SIDE SHIFT SPD',*)
ConfigEnable[14] := TRUE;
(*'ELEV FRONT SS',*)
ConfigEnable[15] := OPT_ElevatorDualRotate;
(*'ELEV REAR SS',*)
ConfigEnable[16] := TRUE;
(*'ELEV CENTER ROTATE',*)
ConfigEnable[17] := OPT_ElevatorDualRotate;
(*'ELEV REAR ROTATE',*)
ConfigEnable[18] := TRUE;
(*'MIN TRANSFER PRESSURE',*)
ConfigEnable[19] := B_SpecialMenu;
(*'DRIVE CREEP SPEED';*)
ConfigEnable[23] := B_SpecialMenu;
(*'DRIVE ASD SPEED';*)
ConfigEnable[24] := B_SpecialMenu;
(*'DRIVE MAX SPEED';*)
ConfigEnable[26] := B_SpecialMenu;
(*'EP1 THRESHOLD',*)
ConfigEnable[29] :=  B_SpecialMenu;
(*'EP2 THRESHOLD',*)
ConfigEnable[30] :=  B_SpecialMenu AND B_OPT_838;
(*'EP31 THRESHOLD',*)
ConfigEnable[31] :=  B_SpecialMenu;
(*'EP32 THRESHOLD',*)
ConfigEnable[32] :=  B_SpecialMenu;
(*'EP61 ELEV THRESHOLD',*)
ConfigEnable[35] :=  B_SpecialMenu AND B_OPT_838;
(*'EP65 REGEN CONTROL THRESHOLD',*)
ConfigEnable[37] :=  B_SpecialMenu AND B_OPT_929;
(*'CAMERA ADJUST',*)
ConfigEnable[40] := OPT_ASD;
(*FORCE MODE*)
ConfigEnable[42] := B_SpecialMenu;
(*SV-90 BYPASS*)
ConfigEnable[43] :=  B_SpecialMenu;
(*SIDE ROLLER BYPASS*)
ConfigEnable[44] :=  B_SpecialMenu;
(*45-BATTERY CURRENT*)
ConfigEnable[45] :=  B_SpecialMenu;
(*46-SOC RESET*)
ConfigEnable[46] :=  B_SpecialMenu AND OPT_LeadAcidBattery;
(*MOTOR PUMP ENABLE';*)
ConfigEnable[48] :=  B_SpecialMenu;
(*MOTOR TRACT ENABLE';*)
ConfigEnable[49] :=  B_SpecialMenu;
(*MOTOR REGEN ENABLE';*)
ConfigEnable[50] :=  B_SpecialMenu;
(*AUTO SHUTDOWN TIMER';*)
ConfigEnable[51] :=  B_SpecialMenu;
(*HOURMETER FORCE';*)
ConfigEnable[61] :=  B_SpecialMenu;

(* Reset LED status *)
LEDF1 := FALSE;
LEDF2 := FALSE;
LEDF3 := FALSE;
LEDF4 := FALSE;
LEDF5 := FALSE;
LEDF6 := FALSE;
LEDF7 := FALSE;
LEDF8 := FALSE;
LEDUP := FALSE;
LEDDOWN := FALSE;
LEDLEFT := FALSE;
LEDRIGHT := FALSE;
LEDOK := FALSE;
LEDESC := FALSE;

(*Reset Command*)
OpBridgeUpCmd := FALSE;
OpBridgeDownCmd := FALSE;
OpBridgeUpFastCmd := FALSE;
OpBridgeDownFastCmd := FALSE;
OpElevUpSlowCmd := FALSE;
OpElevDownSlowCmd := FALSE;
OpElevUpFastCmd := FALSE;
OpElevDownFastCmd := FALSE;
OpBridgeFwdCmd := FALSE;
OpBridgeRevCmd := FALSE;
OpBridgeLeftCmd := FALSE;
OpBridgeRightCmd := FALSE;
OpElevFrontFwdCmd := FALSE;
OpElevFrontRevCmd := FALSE;
OpElevFrontLeftCmd := FALSE;
OpElevFrontRightCmd := FALSE;
OpElevRearFwdCmd := FALSE;
OpElevRearRevCmd := FALSE;
OpElevRearLeftCmd := FALSE;
OpElevRearRightCmd := FALSE;
OPElevCenterRotateCWCmd := FALSE;
OPElevCenterRotateCCWCmd := FALSE;
OPElevRearRotateCWCmd := FALSE;
OPElevRearRotateCCWCmd := FALSE;
OpLeftSideGuideDownCmd := FALSE;
OpRightSideGuideDownCmd := FALSE;
OpRearStopDownCmd := FALSE;
G_ForcePumpEnable := FALSE;
G_ForceSupercaps := FALSE;
G_EP1ThresholdSet := FALSE;
G_EP2ThresholdSet := FALSE;
G_EP31ThresholdSet := FALSE;
G_EP32ThresholdSet := FALSE;
G_EP61ThresholdSet := FALSE;
G_EP65ThresholdSet := FALSE;
G_ChargePressureSet := FALSE;
B_SV90Bypass := FALSE;
G_Force5kmh := FALSE;
G_CameraAdjust := FALSE;
G_HighDemandRequest := FALSE;
B_JogPump := FALSE;
OpRearWheelUpCmd := FALSE;
OpRearWheelDownCmd:= FALSE;

RT_F1(IN := F1_IN);
F1 := RT_F1.Q;
RT_F2(IN := F2_IN);
F2 := RT_F2.Q;
RT_F3(IN := F3_IN);
F3 := RT_F3.Q;
RT_F4(IN := F4_IN);
F4 := RT_F4.Q;
RT_F5(IN := F5_IN);
F5 := RT_F5.Q;
RT_F6(IN := F6_IN);
F6 := RT_F6.Q;
RT_F7(IN := F7_IN);
F7 := RT_F7.Q;
RT_F8(IN := F8_IN);
F8 := RT_F8.Q;
RT_KEY_OK(IN := KEY_OK_IN);
KEY_OK := RT_KEY_OK.Q;
RT_KEY_ESC(IN := KEY_ESC_IN);
KEY_ESC := RT_KEY_ESC.Q;
RT_KEY_LEFT(IN := KEY_LEFT_IN);
KEY_LEFT := RT_KEY_LEFT.Q;
RT_KEY_RIGHT(IN := KEY_RIGHT_IN);
KEY_RIGHT := RT_KEY_RIGHT.Q;
RT_KEY_UP(IN := KEY_UP_IN);
KEY_UP := RT_KEY_UP.Q;
RT_KEY_DOWN(IN := KEY_DOWN_IN);
KEY_DOWN := RT_KEY_DOWN.Q;

TONInitDelay(IN:=TRUE,PT:=T#3s);
TONInitDelay2(IN:=act_picture > 0,PT:=T#6s);

LoadTestCode();
AccessCode();

(*F1 - Operation*)
IF W_StaticID = TL_Operation THEN
	F1_Operation();
(*F2 - Diagnostic*)
ELSIF W_StaticID =  TL_Diagnostic OR W_StaticID = TL_InputsAnalog OR W_StaticID = TL_InputsDigital OR W_StaticID = TL_OutputsAnalog OR W_StaticID = TL_OutputsDigital OR W_StaticID = TL_Network THEN
	F2_Diagnostic();
(*F3 - Configuration*)
ELSIF W_StaticID = TL_Configuration OR W_StaticID = TL_SpecialConfiguration THEN
	F3_Configuration();
(*F4 - Fault*)
ELSIF W_StaticID = TL_FaultLog OR  W_StaticID = TL_DisplayFaults OR  W_StaticID = TL_MotorFaults OR W_StaticID = TL_ASDEventLog OR W_StaticID = TL_EraseAllEntries THEN
	F4_Fault();
(*F5 - Information*)
ELSIF W_StaticID = TL_Information OR W_StaticID = TL_Motors OR  W_StaticID = TL_SystemStatus OR W_StaticID = TL_History OR W_StaticID = TL_Version THEN
	F5_Information();
(* OPTION PAGE*)
ELSIF W_StaticID = TL_OptionsSetup THEN
	Options();
ELSE
	LEDF1 := TRUE;
	LEDF2 := TRUE;
	LEDF3 := TRUE;
	LEDF4 := TRUE;
	LEDF5 := TRUE;
	LEDF6 := TRUE;
END_IF

IF TONInitDelay.Q THEN
	IF page_extern = 0 OR page_extern = 1 (*Init Page*) THEN
		page_extern := 2; (*Main Menu Page*)
	END_IF
	IF B_LoadTestOK THEN
		page_extern := 100; (*Load Test*)
	ELSIF (F4_IN AND F5_IN AND F6_IN AND NOT TONInitDelay2.Q) OR B_OptionBypass THEN
		W_StaticID := TL_OptionsSetup;
		page_extern := 4; (*STD Page*)
		B_OptionBypass := FALSE;
	ELSIF ((F3_IN AND NOT TONInitDelay2.Q) OR B_F3SpecialBypass) AND NOT (W_StaticID = TL_OptionsSetup) THEN
		W_StaticID := TL_SpecialConfiguration;
		B_SpecialMenu := TRUE;
		page_extern := 4; (*STD Page*)
		ConfigSelectedLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
		B_F3SpecialBypass := FALSE;
	ELSIF F1 AND NOT (W_StaticID = TL_Operation) AND NOT (W_StaticID = TL_OptionsSetup)  THEN
		W_StaticID := TL_Operation;
		page_extern := 4;  (*STD Page*)
		B_OperationSpecific := FALSE;
		OperationsSelectedLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	ELSIF F2 AND NOT (W_StaticID =  TL_Diagnostic) AND NOT (W_StaticID = TL_InputsAnalog) AND NOT (W_StaticID = TL_InputsDigital) AND NOT (W_StaticID = TL_OutputsAnalog) AND NOT (W_StaticID = TL_OutputsDigital) AND NOT (W_StaticID = TL_Network) AND NOT (W_StaticID = TL_OptionsSetup) THEN
		W_StaticID := TL_Diagnostic;
		page_extern := 4; (*STD Page*)
		DiagnosticSelectedLine := 0;
		DiagnosticDisplayLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	ELSIF F3 AND NOT (W_StaticID = TL_Configuration) AND NOT (W_StaticID = TL_SpecialConfiguration) AND NOT (W_StaticID = TL_OptionsSetup) THEN
		IF B_SpecialMenu = TRUE THEN
			W_StaticID := TL_SpecialConfiguration;
		ELSE
			W_StaticID := TL_Configuration;
		END_IF
		page_extern := 4; (*STD Page*)
		B_ConfigurationSpecific := FALSE;
		ConfigSelectedLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	ELSIF F4 AND NOT (W_StaticID = TL_FaultLog) AND NOT  (W_StaticID = TL_DisplayFaults) AND NOT  (W_StaticID = TL_MotorFaults) AND NOT (W_StaticID = TL_ASDEventLog) AND NOT ( W_StaticID = TL_EraseAllEntries) AND NOT (W_StaticID = TL_OptionsSetup) THEN
		W_StaticID := TL_FaultLog;
		page_extern := 4; (*STD Page*)
		FaultLogSelectedLine := 0;
		FaultLogDisplayLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	ELSIF F5 AND NOT (W_StaticID = TL_Information) AND NOT (W_StaticID = TL_Motors) AND NOT (W_StaticID = TL_SystemStatus) AND NOT (W_StaticID = TL_History) AND NOT( W_StaticID = TL_Version) AND NOT (W_StaticID = TL_OptionsSetup) THEN
		W_StaticID := TL_Information;
		page_extern := 4; (*STD Page*)
		InformationSelectedLine := 0;
		InformationDisplayLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	END_IF
ELSE
	LEDF1 := TRUE;
	LEDF2 := TRUE;
	LEDF3 := TRUE;
	LEDF4 := TRUE;
	LEDF5 := TRUE;
	LEDF6 := TRUE;

	page_extern := 1; (*INIT PAGE*)
	(* Display program version *)
	Val1 := DWORD_TO_WORD(S_Program);
	Val2 := DWORD_TO_WORD(SHR(S_Program, 16));
	Val3 := S_Version;
END_IF


IF act_picture = 2 AND W_StaticID <> 0 AND page_extern = 2 THEN
	W_StaticID := 0;
END_IF

DiagnosticCenter();

B_Init := FALSE;
END_PROGRAM
ACTION	AccessCode:
CASE BY_F3Code OF
			0:
				IF F3_IN AND KEY_UP THEN
					BY_F3Code := BY_F3Code+1;
				ELSIF KEY_LEFT OR KEY_DOWN OR KEY_RIGHT  OR F1 OR F2 OR F4 OR F5 OR F6  THEN
					BY_F3Code := 0;
				END_IF
			1:
				IF F3_IN AND KEY_DOWN THEN
					BY_F3Code := BY_F3Code+1;
				ELSIF KEY_RIGHT OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F4 OR F5 OR F6  THEN
					BY_F3Code := 0;
				END_IF
			2:
				IF F3_IN AND KEY_UP THEN
					BY_F3Code := BY_F3Code+1;
				ELSIF KEY_LEFT  OR KEY_DOWN OR KEY_RIGHT OR F1 OR F2 OR F4 OR F5 OR F6 THEN
					BY_F3Code := 0;
				END_IF
			3:
				IF F3_IN AND KEY_DOWN THEN
					B_F3SpecialBypass := TRUE;
				ELSIF KEY_UP OR KEY_RIGHT OR KEY_LEFT OR F1 OR F2 OR F4 OR F5 OR F6  THEN
					BY_F3Code := 0;
				END_IF
END_CASE

CASE BY_OptionCode OF
			0:
				IF F4_IN AND F5_IN AND F6_IN AND KEY_ESC THEN
					BY_OptionCode := BY_OptionCode+1;
				ELSIF KEY_LEFT OR KEY_DOWN OR KEY_RIGHT OR KEY_UP  OR F1 OR F2 OR F3 THEN
					BY_OptionCode := 0;
				END_IF
			1:
				IF F4_IN AND F5_IN AND F6_IN AND KEY_ESC THEN
					BY_OptionCode := BY_OptionCode+1;
				ELSIF KEY_RIGHT OR KEY_LEFT OR KEY_UP OR KEY_DOWN OR F1 OR F2 OR F3 THEN
					BY_OptionCode := 0;
				END_IF
			2:
				IF F4_IN AND F5_IN AND F6_IN AND KEY_ESC THEN
					B_OptionBypass := TRUE;
				ELSIF KEY_LEFT  OR KEY_DOWN OR KEY_RIGHT OR KEY_UP OR F1 OR F2 OR F3 THEN
					BY_OptionCode := 0;
				END_IF
END_CASE
END_ACTION

ACTION	F1_Operation:
IF NOT B_OperationSpecific THEN
	LEDOK := TRUE;
	LEDESC := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;

	ScanIndexPointer2 := 0;
	FOR Index := 0 TO 25 DO
		IF OperationsEnable[Index] THEN
			ScanIndex[ScanIndexPointer2] := Index;
			ScanIndexPointer2 := ScanIndexPointer2 + 1;
		END_IF
	END_FOR
	ScanIndexMax := ScanIndexPointer2 - 1;

	IF KEY_LEFT THEN
		IF ScanIndexPointer > MaxLines - 1 THEN
			ScanIndexPointer := ScanIndexPointer - MaxLines;
		ELSE
			ScanIndexPointer := 0;
		END_IF
	END_IF

	IF KEY_RIGHT THEN
		IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
			ScanIndexPointer := ScanIndexPointer + MaxLines;
		ELSE
			ScanIndexPointer := ScanIndexMax - MaxLines + 1;
		END_IF
	END_IF

	IF KEY_UP THEN
		IF SelectedLine = 0 THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		ELSE
			SelectedLine := SelectedLine - 1;
		END_IF
	END_IF

	IF KEY_DOWN THEN
		IF SelectedLine = MaxLines -1 THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		ELSE
			SelectedLine := SelectedLine + 1;
		END_IF
	END_IF

	OperationsSelectedLine := ScanIndex[ScanIndexPointer + SelectedLine];


	IF KEY_OK THEN
		B_OperationSpecific := TRUE;
	END_IF

	IF KEY_ESC THEN
		page_extern := 2; (*MAIN PAGE*)
		OperationsSelectedLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
	END_IF

	TextL1 := OperationsTextList[ScanIndex[ScanIndexPointer]];
	TextL2 := OperationsTextList[ScanIndex[ScanIndexPointer+1]];
	TextL3 := OperationsTextList[ScanIndex[ScanIndexPointer+2]];
	TextL4 := OperationsTextList[ScanIndex[ScanIndexPointer+3]];

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF
ELSIF B_OperationSpecific THEN
	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;
	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDLEFT := FALSE;
	LEDRIGHT := FALSE;
	LEDOK := FALSE;
	LEDESC := TRUE;

	TextL1 := OperationsTextList[OperationsSelectedLine];
	TextL2 := TL_Blank;
	TextL3 := TL_UseTheArrowKeys;
	TextL4 := TL_Blank;

	CASE OperationsSelectedLine OF
		0:
			IF KEY_UP_IN THEN
				OpBridgeUpCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpBridgeDownCmd := TRUE;
			END_IF
		1:
			IF KEY_UP_IN THEN
				OpBridgeUpFastCmd := TRUE;
				OpBridgeUpCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpBridgeDownFastCmd := TRUE;
				OpBridgeDownCmd := TRUE;
			END_IF
		2:
			IF KEY_UP_IN THEN
				OpElevUpSlowCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpElevDownSlowCmd := TRUE;
			END_IF
		3:
			IF KEY_UP_IN THEN
				OpElevUpFastCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpElevDownFastCmd := TRUE;
			END_IF
		6:
			LEDLEFT := OPT_BridgeSS;
			LEDRIGHT := OPT_BridgeSS;

			IF KEY_UP_IN THEN
				OpBridgeFwdCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpBridgeRevCmd := TRUE;
			ELSIF KEY_LEFT_IN AND OPT_BridgeSS THEN
				OpBridgeLeftCmd := TRUE;
			ELSIF KEY_RIGHT_IN AND OPT_BridgeSS THEN
				OpBridgeRightCmd := TRUE;
			END_IF
		7:
			LEDLEFT := OPT_ElevatorDualRotate;
			LEDRIGHT := OPT_ElevatorDualRotate;

			IF KEY_UP_IN THEN
				OpElevFrontFwdCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpElevFrontRevCmd := TRUE;
			ELSIF KEY_LEFT_IN THEN
				OpElevFrontLeftCmd := TRUE;
			ELSIF KEY_RIGHT_IN THEN
				OpElevFrontRightCmd := TRUE;
			END_IF
		8:
			LEDLEFT := TRUE;
			LEDRIGHT := TRUE;

			IF KEY_UP_IN THEN
				OpElevRearFwdCmd := TRUE;
			ELSIF KEY_DOWN_IN THEN
				OpElevRearRevCmd := TRUE;
			ELSIF KEY_LEFT_IN THEN
				OpElevRearLeftCmd := TRUE;
			ELSIF KEY_RIGHT_IN THEN
				OpElevRearRightCmd := TRUE;
			END_IF
		9:
			LEDUP := FALSE;
			LEDDOWN := FALSE;
			LEDLEFT := TRUE;
			LEDRIGHT := TRUE;

			IF KEY_LEFT_IN THEN
				OpElevRearRotateCWCmd := TRUE;
			ELSIF KEY_RIGHT_IN THEN
				OpElevRearRotateCCWCmd := TRUE;
			END_IF
		10:
			LEDUP := FALSE;
			LEDDOWN := FALSE;
			LEDLEFT := TRUE;
			LEDRIGHT := TRUE;

			IF KEY_LEFT_IN THEN
				OpElevRearLeftCmd := TRUE;
				OpElevFrontRightCmd := TRUE;
			ELSIF KEY_RIGHT_IN THEN
				OpElevFrontLeftCmd := TRUE;
				OpElevRearRightCmd := TRUE;
			END_IF
		12:
			LEDUP := FALSE;

			IF KEY_DOWN_IN THEN
				OpLeftSideGuideDownCmd := TRUE;
			END_IF
		13:
			LEDUP := FALSE;

			IF KEY_DOWN_IN THEN
				OpRightSideGuideDownCmd := TRUE;
			END_IF
		14:
			LEDUP := FALSE;

			IF KEY_DOWN_IN THEN
				OpRearStopDownCmd := TRUE;
			END_IF

		17:
			LEDUP := FALSE;
			LEDDOWN := FALSE;

			TextL3 := TL_Blank;

			G_ForcePumpEnable := TRUE;
			G_HighDemandRequest := TRUE;
			B_PumpRotationCheck := FALSE;

		18:
			LEDUP := FALSE;
			LEDDOWN := FALSE;
			LEDOK := TRUE;
			B_InvisibleValue4 := FALSE;

			TextL2 := TL_PressOKToDischarge;
			TextL3 := TL_PowerOFFWhenEmpty;
			TextL4 := TL_SupercapacitorLevel;
			Val4 := SupercapsManagement.BY_SuperCapsLevel;
			IF KEY_OK_IN THEN
				G_ForceSupercaps := TRUE;
			END_IF
	END_CASE

	IF KEY_ESC THEN
		B_OperationSpecific := FALSE;
	END_IF
END_IF
END_ACTION

ACTION	F2_Diagnostic:
IF W_StaticID =  TL_Diagnostic THEN
	LEDLEFT := FALSE;
	LEDRIGHT := FALSE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDOK := TRUE;
	LEDESC := TRUE;
	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;

	TextL1 := DiagnosticTextList[DiagnosticDisplayLine];
	TextL2 := DiagnosticTextList[DiagnosticDisplayLine + 1];
	TextL3 := DiagnosticTextList[DiagnosticDisplayLine + 2];
	TextL4 := DiagnosticTextList[DiagnosticDisplayLine + 3];

	IF KEY_UP THEN
		IF DiagnosticSelectedLine > 0 THEN
			DiagnosticSelectedLine := DiagnosticSelectedLine - 1;
			IF SelectedLine = 0 THEN
				DiagnosticDisplayLine := DiagnosticDisplayLine - 1;
			ELSE
				SelectedLine := SelectedLine - 1;
			END_IF
		ELSE
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
			SelectedLine := 0;
		END_IF
	END_IF

	IF KEY_DOWN THEN
		IF NOT(DiagnosticTextList[DiagnosticSelectedLine+1] = 0) THEN
			DiagnosticSelectedLine := DiagnosticSelectedLine + 1;
			IF SelectedLine = 3 THEN
				DiagnosticDisplayLine := DiagnosticDisplayLine + 1;
			ELSE
				SelectedLine := SelectedLine + 1;
			END_IF
		END_IF
	END_IF

	IF KEY_OK THEN
		ScanIndexPointer := 0;
		DiagnosticDisplayLine := 0;
		SelectedLine := 0;
		CASE DiagnosticSelectedLine OF
			0:	W_StaticID := TL_InputsAnalog;				(* INPUTS ANALOG *)
			1 :	W_StaticID := TL_InputsDigital;				(* INPUTS DIGITAL *)
			2 : 	W_StaticID := TL_OutputsAnalog;			(* OUTPUTS ANALOG *)
			3 : 	W_StaticID := TL_OutputsDigital;				(* OUTPUTS DIGITAL *)
			4 : 	W_StaticID := TL_Network;					(* NETWORK *)
		END_CASE
	END_IF

	IF KEY_ESC THEN
		page_extern := 2; (*MAIN PAGE*)
		DiagnosticSelectedLine := 0;
		DiagnosticDisplayLine := 0;
		SelectedLine := 0;
	END_IF

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF

ELSIF W_StaticID = TL_InputsAnalog OR W_StaticID = TL_InputsDigital OR W_StaticID = TL_OutputsAnalog OR W_StaticID = TL_OutputsDigital OR W_StaticID = TL_Network THEN
	LEDESC := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	B_InvisibleValue1 := FALSE;
	B_InvisibleValue2 := FALSE;
	B_InvisibleValue3 := FALSE;
	B_InvisibleValue4 := FALSE;
	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;

	CASE DiagnosticSelectedLine OF
	0:					(* ******************* DIAGNOSTIC ANALOG INPUTS ******************** *)
		(* Scan list of inputs *)
		ScanIndexPointer2 := 0;
		Index := 0;
		WHILE (Index <= MaxIndexInputsA) DO
			IF G_InputsA[Index].B_Active AND G_InputsA[Index].B_Diagnostic THEN
				ScanIndex[ScanIndexPointer2] := Index;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
			SelectedLine := 0;
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		TextL1 := G_InputsA[ScanIndex[ScanIndexPointer]].S_Name;
		IF G_InputsA[ScanIndex[ScanIndexPointer]].B_Analog0Digital1 THEN
			 Val1 := BOOL_TO_WORD(G_InputsA[ScanIndex[ScanIndexPointer]].B_Value);
		ELSE
			 Val1 := (G_InputsA[ScanIndex[ScanIndexPointer]].I_Value);
		END_IF
		TextL2 := G_InputsA[ScanIndex[ScanIndexPointer+1] ].S_Name;
		IF G_InputsA[ScanIndex[ScanIndexPointer+1]].B_Analog0Digital1 THEN
			 Val2 := BOOL_TO_WORD(G_InputsA[ScanIndex[ScanIndexPointer+1]].B_Value);
		ELSE
			 Val2 := (G_InputsA[ScanIndex[ScanIndexPointer+1]].I_Value);
		END_IF
		TextL3 := G_InputsA[ScanIndex[ScanIndexPointer+2]].S_Name;
		IF G_InputsA[ScanIndex[ScanIndexPointer+2]].B_Analog0Digital1 THEN
			 Val3 := BOOL_TO_WORD(G_InputsA[ScanIndex[ScanIndexPointer+2]].B_Value);
		ELSE
			 Val3 := (G_InputsA[ScanIndex[ScanIndexPointer+2]].I_Value);
		END_IF
		TextL4 := G_InputsA[ScanIndex[ScanIndexPointer+3]].S_Name;
		IF G_InputsA[ScanIndex[ScanIndexPointer+3]].B_Analog0Digital1 THEN
			 Val4 := BOOL_TO_WORD(G_InputsA[ScanIndex[ScanIndexPointer+3]].B_Value);
		ELSE
			 Val4 := (G_InputsA[ScanIndex[ScanIndexPointer+3]].I_Value);
		END_IF

		IF KEY_ESC THEN
			W_StaticID :=  TL_Diagnostic;
			SelectedLine := 0;
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
		END_IF

	1:					(* ******************* DIAGNOSTIC DIGITAL INPUTS ******************** *)
		(* Scan list of inputs *)
		ScanIndexPointer2 := 0;
		Index := 0;
		WHILE (Index <= MaxIndexInputsD) DO
			IF G_InputsD[Index].B_Active AND G_InputsD[Index].B_Diagnostic THEN
				ScanIndex[ScanIndexPointer2] := Index;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
			SelectedLine := 0;
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		TextL1 := G_InputsD[ScanIndex[ScanIndexPointer]].S_Name;
		IF G_InputsD[ScanIndex[ScanIndexPointer]].B_Analog0Digital1 THEN
			 Val1 := BOOL_TO_WORD(G_InputsD[ScanIndex[ScanIndexPointer]].B_Value);
		ELSE
			 Val1 := (G_InputsD[ScanIndex[ScanIndexPointer]].I_Value);
		END_IF
		TextL2 := G_InputsD[ScanIndex[ScanIndexPointer+1] ].S_Name;
		IF G_InputsD[ScanIndex[ScanIndexPointer+1]].B_Analog0Digital1 THEN
			 Val2 := BOOL_TO_WORD(G_InputsD[ScanIndex[ScanIndexPointer+1]].B_Value);
		ELSE
			 Val2 := (G_InputsD[ScanIndex[ScanIndexPointer+1]].I_Value);
		END_IF
		TextL3 := G_InputsD[ScanIndex[ScanIndexPointer+2]].S_Name;
		IF G_InputsD[ScanIndex[ScanIndexPointer+2]].B_Analog0Digital1 THEN
			 Val3 := BOOL_TO_WORD(G_InputsD[ScanIndex[ScanIndexPointer+2]].B_Value);
		ELSE
			 Val3 := (G_InputsD[ScanIndex[ScanIndexPointer+2]].I_Value);
		END_IF
		TextL4 := G_InputsD[ScanIndex[ScanIndexPointer+3]].S_Name;
		IF G_InputsD[ScanIndex[ScanIndexPointer+3]].B_Analog0Digital1 THEN
			 Val4 := BOOL_TO_WORD(G_InputsD[ScanIndex[ScanIndexPointer+3]].B_Value);
		ELSE
			 Val4 := (G_InputsD[ScanIndex[ScanIndexPointer+3]].I_Value);
		END_IF

		IF KEY_ESC THEN
			W_StaticID :=  TL_Diagnostic;
			SelectedLine := 0;
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
		END_IF

	2:					(* ******************* DIAGNOSTIC ANALOG OUTPUTS ******************** *)
		(* Scan list of outputs *)
		ScanIndexPointer2 := 0;
		Index := 0;
		WHILE (Index <= MaxIndexOutputsA) DO
			IF G_OutputsA[Index].B_Active AND G_OutputsA[Index].B_Diagnostic THEN
				ScanIndex[ScanIndexPointer2] := Index;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
			SelectedLine := 0;
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		TextL1 := G_OutputsA[ScanIndex[ScanIndexPointer]].S_Name;
		 Val1 := (G_OutputsA[ScanIndex[ScanIndexPointer]].I_Value);
		TextL2 := G_OutputsA[ScanIndex[ScanIndexPointer+1] ].S_Name;
		 Val2 := (G_OutputsA[ScanIndex[ScanIndexPointer+1]].I_Value);
		TextL3 := G_OutputsA[ScanIndex[ScanIndexPointer+2]].S_Name;
		 Val3 := (G_OutputsA[ScanIndex[ScanIndexPointer+2]].I_Value);
		TextL4 := G_OutputsA[ScanIndex[ScanIndexPointer+3]].S_Name;
		 Val4 := (G_OutputsA[ScanIndex[ScanIndexPointer+3]].I_Value);

		IF KEY_ESC THEN
			W_StaticID :=  TL_Diagnostic;
			SelectedLine := 0;
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
		END_IF

	3:					(* ******************* DIAGNOSTIC DIGITAL OUTPUTS ******************** *)
		(* Scan list of outputs *)
		ScanIndexPointer2 := 0;
		Index := 0;
		WHILE (Index <= MaxIndexOutputsD) DO
			IF G_OutputsD[Index].B_Active AND G_OutputsD[Index].B_Diagnostic THEN
				ScanIndex[ScanIndexPointer2] := Index;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
			SelectedLine := 0;
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		TextL1 := G_OutputsD[ScanIndex[ScanIndexPointer]].S_Name;
		 Val1 := BOOL_TO_WORD(G_OutputsD[ScanIndex[ScanIndexPointer]].B_Value);
		TextL2 := G_OutputsD[ScanIndex[ScanIndexPointer+1]].S_Name;
		 Val2 := BOOL_TO_WORD(G_OutputsD[ScanIndex[ScanIndexPointer+1]].B_Value);
		TextL3 := G_OutputsD[ScanIndex[ScanIndexPointer+2]].S_Name;
		 Val3 := BOOL_TO_WORD(G_OutputsD[ScanIndex[ScanIndexPointer+2]].B_Value);
		TextL4 := G_OutputsD[ScanIndex[ScanIndexPointer+3]].S_Name;
		 Val4 := BOOL_TO_WORD(G_OutputsD[ScanIndex[ScanIndexPointer+3]].B_Value);

		IF KEY_ESC THEN
			W_StaticID :=  TL_Diagnostic;
			SelectedLine := 0;
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
		END_IF

	4:					(* ******************* NETWORK STATUS ******************** *)

		ScanIndexMax := 21;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		(* Network modules list, display the right values *)
		index := 0;
 		WHILE index <= ScanIndexPointer DO
			B_SkipLine := FALSE;
			IF NOT B_OPT_838 AND index = 3 THEN
				B_SkipLine := TRUE;
			END_IF
			IF NOT OPT_ElevatorLiftJoystick AND index = 9 THEN
				B_SkipLine := TRUE;
			END_IF
			IF NOT OPT_BridgeLiftJoystick AND index = 10 THEN
				B_SkipLine := TRUE;
			END_IF
			IF NOT OPT_DriveJoystick AND index = 11 THEN
				B_SkipLine := TRUE;
			END_IF
			IF (NOT OPT_DCDCSystem OR NOT OPT_LeadAcidBattery) AND index = 15 THEN
				B_SkipLine := TRUE;
			END_IF
			IF NOT OPT_ASD AND index = 18 THEN
				B_Skipline := TRUE;
			END_IF

			(* Shift lines to be displayed *)
			IF index > 0 AND NOT B_SkipLine THEN
				TextL1 := TextL2;
				Val1 := Val2;
				TextL2 := TextL3;
				Val2 := Val3;
				TextL3 := TextL4;
				Val3 := Val4;
			END_IF

			IF NOT B_SkipLine THEN
				CASE index OF
				0:
					TextL1 := TL_ChassisModule1ID4;
					Val1 := BOOL_TO_WORD(Node4Operational);
					TextL2 := TL_BridgeModule1ID16;
					Val2 := BOOL_TO_WORD(Node16Operational);
					TextL3 := TL_BridgeModule2ID17;
					Val3 := BOOL_TO_WORD(Node17Operational);
					TextL4 := TL_ElevatorModule1ID20;
					Val4 := BOOL_TO_WORD(Node20Operational);
				1:
					TextL4 := TL_ElevatorModule2ID21;
					Val4 := BOOL_TO_WORD(Node21Operational);
				2:
					TextL4 := TL_ElevatorModule3ID24;
					Val4 := BOOL_TO_WORD(Node24Operational);
				3:
					TextL4 := TL_InclinometerID10;
					Val4 := BOOL_TO_WORD(Node10Operational);
				4:
					TextL4 := TL_SM1CargoSwitchModule;
					Val4 := BOOL_TO_WORD(NOT Cargo_Console.SwitchModule.B_ModuleFault);
				5:
					TextL4 := TL_SM2DriverSwitchModule;
					Val4 := BOOL_TO_WORD(NOT Driver_Console.SwitchModule.B_ModuleFault);
				6:
					TextL4 := TL_RearElevatorJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.ElevatorRearCargo.B_JoystickFault);
				7:
					TextL4 := TL_FrontElevatorJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.ElevatorFrontCargo.B_JoystickFault);
				8:
					TextL4 := TL_BridgeCargoJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.BridgeCargo.B_JoystickFault);
				9:
					TextL4 :=  TL_J4_ElevatorLiftJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.ElevatorLift.B_JoystickFault);
				10:
					TextL4 :=  TL_J5_BridgeLiftJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.BridgeLift.B_JoystickFault);
				11:
					TextL4 := TL_J10_DriveJoystick;
					Val4 := BOOL_TO_WORD(NOT Joystick.DriveJoystick.B_JoystickFault);
				12:
					TextL4 := TL_PumpControllerID11;
					Val4 := BOOL_TO_WORD(Node11Operational_3);
				13:
					TextL4 := TL_TractionControllerID12;
					Val4 := BOOL_TO_WORD(Node12Operational_3);
				14:
					TextL4 := TL_RegenControllerID13;
					Val4 := BOOL_TO_WORD(Node13Operational_3);
				15:
					TextL4 := TL_DCDCSystemID31;
					Val4 := BOOL_TO_WORD(Node31Operational_4);
				16:
					IF OPT_LeadAcidBattery THEN
						TextL4 := TL_AcuityModuleID42;
						Val4 := BOOL_TO_WORD(Node42Operational_3);
					ELSIF OPT_GreenCubeBattery THEN
						TextL4 := TL_BMSModuleID28;
						Val4 := BOOL_TO_WORD(Node28Operational_4);
					ELSIF OPT_TLDiBSBattery THEN
						TextL4 :=  TL_IBSBatteryID;
						Val4 := BOOL_TO_WORD(NodeIBSOperational_4);
					END_IF
				17:
					TextL4 := TL_ConsoleModuleID91;
					Val4 := BOOL_TO_WORD(Node91Operational);
				18:
					TextL4 := TL_ASDCameraNetwork;
					Val4 := BOOL_TO_WORD(ConsoleDisplay.TOF_CameraAlive.Q) ;
				END_CASE
			END_IF

			(* Increment index until last line *)
			index := index + 1;
		END_WHILE

		IF KEY_ESC THEN
			W_StaticID :=  TL_Diagnostic;
			SelectedLine := 0;
			DiagnosticSelectedLine := 0;
			DiagnosticDisplayLine := 0;
		END_IF
	END_CASE
END_IF
END_ACTION

ACTION	F3_Configuration:
IF NOT B_ConfigurationSpecific THEN

	LEDOK := TRUE;
	LEDESC := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;

	ScanIndexPointer2 := 0;
	FOR Index := 0 TO 70 DO
		IF ConfigEnable[Index] THEN
			ScanIndex[ScanIndexPointer2] := Index;
			ScanIndexPointer2 := ScanIndexPointer2 + 1;
		END_IF
	END_FOR
	ScanIndexMax := ScanIndexPointer2 - 1;

	IF KEY_LEFT THEN
		IF ScanIndexPointer > MaxLines - 1 THEN
			ScanIndexPointer := ScanIndexPointer - MaxLines;
		ELSE
			ScanIndexPointer := 0;
		END_IF
	END_IF

	IF KEY_RIGHT THEN
		IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
			ScanIndexPointer := ScanIndexPointer + MaxLines;
		ELSE
			ScanIndexPointer := ScanIndexMax - MaxLines + 1;
		END_IF
	END_IF

	IF KEY_UP THEN
		IF SelectedLine = 0 THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		ELSE
			SelectedLine := SelectedLine - 1;
		END_IF
	END_IF

	IF KEY_DOWN THEN
		IF SelectedLine = MaxLines -1 THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		ELSE
			SelectedLine := SelectedLine + 1;
		END_IF
	END_IF

	ConfigSelectedLine := ScanIndex[ScanIndexPointer + SelectedLine];

	IF KEY_OK THEN
		B_ConfigurationSpecific := TRUE;
		W_ElapsedTime := 0;
	END_IF

	IF KEY_ESC THEN
		page_extern := 2; (*MAIN PAGE*)
		ConfigSelectedLine := 0;
		ScanIndexPointer := 0;
		SelectedLine := 0;
		B_SetSerialNumber := FALSE;
	END_IF

	TextL1 := ConfigTextList[ScanIndex[ScanIndexPointer]];
	TextL2 := ConfigTextList[ScanIndex[ScanIndexPointer+1]];
	TextL3 := ConfigTextList[ScanIndex[ScanIndexPointer+2]];
	TextL4 := ConfigTextList[ScanIndex[ScanIndexPointer+3]];

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF

ELSIF B_ConfigurationSpecific THEN

	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDOK := FALSE;
	LEDESC := TRUE;

	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;

	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;

	TextL1 := ConfigTextList[ConfigSelectedLine];

	IF KEY_ESC THEN
		B_ConfigurationSpecific := FALSE;
		W_ElapsedTime := 0;
		B_SetSerialNumber := FALSE;
		G_SideRollerBypassLeft := FALSE;
		G_SideRollerBypassRight := FALSE;
		B_HoldKeyUp := FALSE;
		B_HoldKeyDown := FALSE;
	END_IF

	CASE ConfigSelectedLine OF

		0:
			LEDOK := TRUE;

			TextL2 := TL_UnitSerialNumber;

			Val1 := DWORD_TO_WORD(DW_SerialNumber);
			Val2 := DWORD_TO_WORD(SHR(DW_SerialNumber, 16));

			IF NOT B_SetSerialNumber THEN
				TextL3 := TL_PressOkToSet;
			ELSE
				TextL3 := TL_Confirmed;
			END_IF

			IF KEY_LEFT THEN
				IF BY_DigitSelected > 1 THEN
					BY_DigitSelected := BY_DigitSelected - 1;
				END_IF
			END_IF
	
			IF KEY_RIGHT THEN
				IF BY_DigitSelected < 6 THEN
					BY_DigitSelected := BY_DigitSelected + 1;
				END_IF
			END_IF

			IF KEY_UP OR KEY_DOWN THEN
				B_SetSerialNumber := FALSE;
			END_IF

			IF KEY_OK THEN
				B_SetSerialNumber := TRUE;
			END_IF
	
			CASE BY_DigitSelected OF
				1 : TextL4 := TL_SN100000;
					IF KEY_UP THEN
						IF DW_SerialNumber < 900000 THEN
							DW_SerialNumber := DW_SerialNumber + 100000;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 100000 THEN
							DW_SerialNumber := DW_SerialNumber - 100000;
						END_IF
					END_IF
	
				2 :	TextL4 := TL_SN10000;
					IF KEY_UP THEN
						IF DW_SerialNumber < 990000 THEN
							DW_SerialNumber := DW_SerialNumber + 10000;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 10000 THEN
							DW_SerialNumber := DW_SerialNumber - 10000;
						END_IF
					END_IF
	
				3 : TextL4 := TL_SN1000;
					IF KEY_UP THEN
						IF DW_SerialNumber < 999000 THEN
							DW_SerialNumber := DW_SerialNumber + 1000;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 1000 THEN
							DW_SerialNumber := DW_SerialNumber - 1000;
						END_IF
					END_IF
	
				4 : TextL4 := TL_SN100;
					IF KEY_UP THEN
						IF DW_SerialNumber < 999900 THEN
							DW_SerialNumber := DW_SerialNumber + 100;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 100 THEN
							DW_SerialNumber := DW_SerialNumber - 100;
						END_IF
					END_IF
	
				5 :  TextL4 := TL_SN10;
					IF KEY_UP THEN
						IF DW_SerialNumber < 999990 THEN
							DW_SerialNumber := DW_SerialNumber + 10;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 10 THEN
							DW_SerialNumber := DW_SerialNumber - 10;
						END_IF
					END_IF
	
				 6: TextL4 := TL_SN1;
					IF KEY_UP THEN
						IF DW_SerialNumber < 999999 THEN
							DW_SerialNumber := DW_SerialNumber + 1;
						END_IF
					END_IF
	
					IF KEY_DOWN THEN
						IF DW_SerialNumber > 1 THEN
							DW_SerialNumber := DW_SerialNumber - 1;
						END_IF
					END_IF
			END_CASE

	1:
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;
		TextL2 := TL_Speed01000;
		 Val2 := G_BridgeUpMaxSpeed;
		TextL3 := TL_TimeMS;
		 Val3 := W_ElapsedTime;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_BridgeUpMaxSpeed > 0 THEN
				G_BridgeUpMaxSpeed := G_BridgeUpMaxSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_BridgeUpMaxSpeed < 1000 THEN
				G_BridgeUpMaxSpeed := G_BridgeUpMaxSpeed + 10;
			END_IF
		END_IF

		IF G_OutputsD[COutBridgeLiftEnable].B_Value THEN
			W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme);
		ELSE
			T_StartTime := TIME();
		END_IF

		IF KEY_UP_IN THEN
			OpBridgeUpFastCmd := TRUE;
			OpBridgeUpCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpBridgeDownFastCmd := TRUE;
			OpBridgeDownCmd := TRUE;
		END_IF

	2:
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;
		TextL2 := TL_Speed01000;
		 Val2 := G_BridgeDownMaxSpeed;
		TextL3 := TL_TimeMS;
		 Val3 := W_ElapsedTime;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_BridgeDownMaxSpeed > 0 THEN
				G_BridgeDownMaxSpeed := G_BridgeDownMaxSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_BridgeDownMaxSpeed < 1000 THEN
				G_BridgeDownMaxSpeed := G_BridgeDownMaxSpeed + 10;
			END_IF
		END_IF

		IF G_OutputsD[COutBridgeLiftEnable].B_Value THEN
			W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme);
		ELSE
			T_StartTime := TIME();
		END_IF

		IF KEY_UP_IN THEN
			OpBridgeUpFastCmd := TRUE;
			OpBridgeUpCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpBridgeDownFastCmd := TRUE;
			OpBridgeDownCmd := TRUE;
		END_IF

	3:
		IF B_OPT_838 THEN
			LEDLEFT := FALSE;
			LEDRIGHT := FALSE;
			B_InvisibleValue3 := FALSE;
			TextL2 := TL_ManualAdjustment;
			TextL3 := TL_TimeMS;
			Val3 := W_ElapsedTime;
			TextL4 := TL_Move;
		ELSE (*929*)
			B_InvisibleValue2 := FALSE;
			TextL2 := TL_Speed0400;
			Val2 := G_BridgeUpSlowSpeed;
			TextL3 := TL_Blank;
			TextL4 := TL_AdjustMove;
		END_IF

		IF B_OPT_929 THEN
			IF KEY_LEFT THEN
				IF G_BridgeUpSlowSpeed > 0 THEN
					G_BridgeUpSlowSpeed := G_BridgeUpSlowSpeed - 10;
				END_IF
			END_IF

			IF KEY_RIGHT THEN
				IF G_BridgeUpSlowSpeed < 400 THEN
					G_BridgeUpSlowSpeed := G_BridgeUpSlowSpeed + 10;
				END_IF
			END_IF
		ELSE
			IF G_OutputsD[COutBridgeUp].B_Value OR G_OutputsD[COutBridgeDown].B_Value THEN
				W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme);
			ELSE
				T_StartTime := TIME();
			END_IF
		END_IF

		IF KEY_UP_IN THEN
			OpBridgeUpCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpBridgeDownCmd := TRUE;
		END_IF

	4:
		IF B_OPT_838 THEN
			LEDLEFT := FALSE;
			LEDRIGHT := FALSE;
			B_InvisibleValue3 := FALSE;
			TextL2 := TL_ManualAdjustment;
			TextL3 := TL_TimeMS;
			Val3 := W_ElapsedTime;
			TextL4 := TL_Move;
		ELSE (*929*)
			B_InvisibleValue2 := FALSE;
			TextL2 := TL_Speed0400;
			Val2 := G_BridgeDownSlowSpeed;
			TextL3 := TL_TestBridgeLandingToTheFrame;
			TextL4 := TL_AdjustMove;
		END_IF

		IF B_OPT_929 THEN
			IF KEY_LEFT THEN
				IF G_BridgeDownSlowSpeed > 0 THEN
					G_BridgeDownSlowSpeed := G_BridgeDownSlowSpeed - 10;
				END_IF
			END_IF

			IF KEY_RIGHT THEN
				IF G_BridgeDownSlowSpeed < 400 THEN
					G_BridgeDownSlowSpeed := G_BridgeDownSlowSpeed + 10;
				END_IF
			END_IF

			IF KEY_UP_IN THEN
				OpBridgeUpCmd := TRUE;
			END_IF

			IF KEY_DOWN_IN THEN
				OpBridgeDownCmd := TRUE;
			END_IF
		ELSE
			IF G_OutputsD[COutBridgeUpFast].B_Value OR G_OutputsD[COutBridgeDownFast].B_Value THEN
				W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme);
			ELSE
				T_StartTime := TIME();
			END_IF

			IF KEY_UP_IN THEN
				OpBridgeUpFastCmd := TRUE;
				OpBridgeUpCmd := TRUE;
			END_IF

			IF KEY_DOWN_IN THEN
				OpBridgeDownFastCmd := TRUE;
				OpBridgeDownCmd := TRUE;
			END_IF
		END_IF

	5:
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;
		TextL2 := TL_Speed01000;
		 Val2 := G_ElevatorUpMaxSpeed;
		TextL3 := TL_TimeMS;
		 Val3 := W_ElapsedTime;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_ElevatorUpMaxSpeed > 0 THEN
				G_ElevatorUpMaxSpeed := G_ElevatorUpMaxSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorUpMaxSpeed < 1000 THEN
				G_ElevatorUpMaxSpeed := G_ElevatorUpMaxSpeed + 10;
			END_IF
		END_IF

		IF G_OutputsD[COutLiftEnable].B_Value THEN
			W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme);
		ELSE
			T_StartTime := TIME();
		END_IF

		IF KEY_UP_IN THEN
			OpElevUpFastCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpElevDownFastCmd := TRUE;
		END_IF

	6:
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ElevatorDownMaxSpeed;
		TextL3 := TL_TimeMS;
		 Val3 := W_ElapsedTime;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_ElevatorDownMaxSpeed > 0 THEN
				G_ElevatorDownMaxSpeed := G_ElevatorDownMaxSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorDownMaxSpeed < 1000 THEN
				G_ElevatorDownMaxSpeed := G_ElevatorDownMaxSpeed + 10;
			END_IF
		END_IF

		IF G_OutputsD[COutLiftEnable].B_Value THEN
			W_ElapsedTime := TIME_TO_WORD(TIME() - T_StartTIme) / 100;
		ELSE
			T_StartTime := TIME();
		END_IF

		IF KEY_UP_IN THEN
			OpElevUpFastCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpElevDownFastCmd := TRUE;
		END_IF

	7:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed501000;
		Val2 := G_ElevatorUpSlowSpeed;
		TextL3 := TL_TestElevatorToBridgeInterface;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_ElevatorUpSlowSpeed > 50 THEN
				G_ElevatorUpSlowSpeed := G_ElevatorUpSlowSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorUpSlowSpeed < 1000 THEN
				G_ElevatorUpSlowSpeed := G_ElevatorUpSlowSpeed + 10;
			END_IF
		END_IF

		IF KEY_UP_IN THEN
			OpElevUpFastCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpElevDownFastCmd := TRUE;
		END_IF

	8:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed0400;
		Val2 := G_ElevatorDownSlowSpeed;
		TextL3 := TL_TestElevatorLandingToTheFrame;
		TextL4 := TL_AdjustMove;

		IF KEY_LEFT THEN
			IF G_ElevatorDownSlowSpeed > 0 THEN
				G_ElevatorDownSlowSpeed := G_ElevatorDownSlowSpeed - 10;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorDownSlowSpeed < 400 THEN
				G_ElevatorDownSlowSpeed := G_ElevatorDownSlowSpeed + 10;
			END_IF
		END_IF

		IF KEY_UP_IN THEN
			OpElevUpFastCmd := TRUE;
		END_IF

		IF KEY_DOWN_IN THEN
			OpElevDownFastCmd := TRUE;
		END_IF

	9:
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_HoldKeyToActivatePumpRotation;
		TextL4 := TL_Blank;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			G_ChargePressureSet := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			G_ChargePressureSet := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

	11:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedBridge;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpBridgeFwdCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpBridgeRevCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedBridge < 1000 THEN
				G_ConveySpeedBridge := G_ConveySpeedBridge + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedBridge > 0 THEN
				G_ConveySpeedBridge := G_ConveySpeedBridge - 10;
			END_IF
		END_IF


	12:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedFrontElevator;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevFrontFwdCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevFrontRevCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedFrontElevator < 1000 THEN
				G_ConveySpeedFrontElevator := G_ConveySpeedFrontElevator + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedFrontElevator > 0 THEN
				G_ConveySpeedFrontElevator := G_ConveySpeedFrontElevator - 10;
			END_IF
		END_IF

	13:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedRearElevator;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevRearFwdCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevRearRevCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedRearElevator < 1000 THEN
				G_ConveySpeedRearElevator := G_ConveySpeedRearElevator + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedRearElevator > 0 THEN
				G_ConveySpeedRearElevator := G_ConveySpeedRearElevator - 10;
			END_IF
		END_IF

	14:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedBridgeSideShift;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpBridgeRightCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpBridgeLeftCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedBridgeSideShift < 1000 THEN
				G_ConveySpeedBridgeSideShift := G_ConveySpeedBridgeSideShift + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedBridgeSideShift > 0 THEN
				G_ConveySpeedBridgeSideShift := G_ConveySpeedBridgeSideShift - 10;
			END_IF
		END_IF

	15:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedElevatorFrontSideShift;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevFrontRightCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevFrontLeftCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedElevatorFrontSideShift < 1000 THEN
				G_ConveySpeedElevatorFrontSideShift := G_ConveySpeedElevatorFrontSideShift + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedElevatorFrontSideShift > 0 THEN
				G_ConveySpeedElevatorFrontSideShift := G_ConveySpeedElevatorFrontSideShift - 10;
			END_IF
		END_IF

	16:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ConveySpeedElevatorRearSideShift;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevRearRightCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevRearLeftCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ConveySpeedElevatorRearSideShift < 1000 THEN
				G_ConveySpeedElevatorRearSideShift := G_ConveySpeedElevatorRearSideShift + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ConveySpeedElevatorRearSideShift > 0 THEN
				G_ConveySpeedElevatorRearSideShift := G_ConveySpeedElevatorRearSideShift - 10;
			END_IF
		END_IF

	17:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ElevatorCenterRotateSpeed;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevCenterRotateCWCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevCenterRotateCCWCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorCenterRotateSpeed < 1000 THEN
				G_ElevatorCenterRotateSpeed := G_ElevatorCenterRotateSpeed + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ElevatorCenterRotateSpeed > 0 THEN
				G_ElevatorCenterRotateSpeed := G_ElevatorCenterRotateSpeed - 10;
			END_IF
		END_IF

	18:
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_Speed01000;
		 Val2 := G_ElevatorRearRotateSpeed;
		TextL3 := TL_Blank;
		TextL4 := TL_AdjustMove;

		IF KEY_UP_IN OR B_HoldKeyUp THEN
			OpElevRearRotateCWCmd := TRUE;
			IF F6 THEN
				B_HoldKeyUp := TRUE;
			END_IF
			B_HoldKeyDown := FALSE;
		END_IF

		IF KEY_DOWN_IN OR B_HoldKeyDown THEN
			OpElevRearRotateCCWCmd := TRUE;
			IF F6 THEN
				B_HoldKeyDown := TRUE;
			END_IF
			B_HoldKeyUp := FALSE;
		END_IF

		IF KEY_RIGHT THEN
			IF G_ElevatorRearRotateSpeed < 1000 THEN
				G_ElevatorRearRotateSpeed := G_ElevatorRearRotateSpeed + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ElevatorRearRotateSpeed > 0 THEN
				G_ElevatorRearRotateSpeed := G_ElevatorRearRotateSpeed - 10;
			END_IF
		END_IF

	19:
		B_InvisibleValue2 := FALSE;
		LEDUP := FALSE;
		LEDDOWN := FALSE;

		TextL2 := TL_Pressure5002500;
		Val2 := G_MinTransferPressure;
		TextL3 := TL_Blank;
		TextL4 := TL_Adjust;

		IF KEY_RIGHT THEN
			IF G_MinTransferPressure < 2500 THEN
				G_MinTransferPressure := G_MinTransferPressure + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_MinTransferPressure > 500 THEN
				G_MinTransferPressure := G_MinTransferPressure - 10;
			END_IF
		END_IF

	23:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;

		IF T1s THEN
			R_DriveSpeed5 := R_DriveSpeed4;
			R_DriveSpeed4 := R_DriveSpeed3;
			R_DriveSpeed3 := R_DriveSpeed2;
			R_DriveSpeed2 := R_DriveSpeed1;
			R_DriveSpeed1 := INT_TO_REAL(G_InputsA[CInDriveSpeed].I_Value);
			R_DriveSpeed := REAL_TO_WORD((R_DriveSpeed1 + R_DriveSpeed2 + R_DriveSpeed3 + R_DriveSpeed4 + R_DriveSpeed5) / 5.0);
		END_IF

		TextL2 := TL_SpeedLess5000;
		 Val2 := G_CreepSpeed;
		TextL3 := TL_ActualSpeed;
		 Val3 := R_DriveSpeed;
		TextL4 := TL_PressESCToGoBack;

		IF KEY_RIGHT THEN
			IF G_CreepSpeed < 5000 THEN
				G_CreepSpeed := G_CreepSpeed + 100;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_CreepSpeed > 100 THEN
				G_CreepSpeed := G_CreepSpeed - 100;
			END_IF
		END_IF

	24:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;

		IF T1s THEN
			R_DriveSpeed5 := R_DriveSpeed4;
			R_DriveSpeed4 := R_DriveSpeed3;
			R_DriveSpeed3 := R_DriveSpeed2;
			R_DriveSpeed2 := R_DriveSpeed1;
			R_DriveSpeed1 := INT_TO_REAL(G_InputsA[CInDriveSpeed].I_Value);
			R_DriveSpeed := REAL_TO_WORD((R_DriveSpeed1 + R_DriveSpeed2 + R_DriveSpeed3 + R_DriveSpeed4 + R_DriveSpeed5) / 5.0);
		END_IF

		TextL2 := TL_SpeedLess7000;
		 Val2 := G_ASDSpeed;
		TextL3 := TL_ActualSpeed;
		 Val3 := R_DriveSpeed;
		TextL4 := TL_PressESCToGoBack;

		IF KEY_RIGHT THEN
			IF G_ASDSpeed < 7000 THEN
				G_ASDSpeed := G_ASDSpeed + 100;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_ASDSpeed > 0 THEN
				G_ASDSpeed := G_ASDSpeed - 100;
			END_IF
		END_IF

		G_Force5kmh := TRUE;

	26:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;

		IF T1s THEN
			R_DriveSpeed5 := R_DriveSpeed4;
			R_DriveSpeed4 := R_DriveSpeed3;
			R_DriveSpeed3 := R_DriveSpeed2;
			R_DriveSpeed2 := R_DriveSpeed1;
			R_DriveSpeed1 := INT_TO_REAL(G_InputsA[CInDriveSpeed].I_Value);
			R_DriveSpeed := REAL_TO_WORD((R_DriveSpeed1 + R_DriveSpeed2 + R_DriveSpeed3 + R_DriveSpeed4 + R_DriveSpeed5) / 5.0);
		END_IF

		TextL2 := TL_SpeedLess15000;
		 Val2 := G_DriveMaxSpeed;
		TextL3 := TL_ActualSpeed;
		 Val3 := R_DriveSpeed;
		TextL4 := TL_PressESCToGoBack;

		IF KEY_RIGHT THEN
			IF G_DriveMaxSpeed < 15000 THEN
				G_DriveMaxSpeed := G_DriveMaxSpeed + 100;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_DriveMaxSpeed > 300 THEN
				G_DriveMaxSpeed := G_DriveMaxSpeed - 100;
			END_IF
		END_IF

	29:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_SetPoint;
		Val2 := G_EP1Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP1Threshold < 300 THEN
				G_EP1Threshold := G_EP1Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP1Threshold > 50 THEN
				G_EP1Threshold := G_EP1Threshold - 5;
			END_IF
		END_IF

		(* Force Bridge Forward *)
		G_EP1ThresholdSet := TRUE;

	30:
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;

		IF G_EP2Threshold > 500 THEN
			G_EP2Threshold := 500;
		END_IF

		TextL2 := TL_SetPoint;
		Val2 := G_EP2Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP2Threshold < 500 THEN
				G_EP2Threshold := G_EP2Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP2Threshold > 50 THEN
				G_EP2Threshold := G_EP2Threshold - 5;
			END_IF
		END_IF
		IF KEY_UP_IN THEN
			(* Force Elevator Up *)
			G_EP2ThresholdSet := TRUE;
		END_IF

	31:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_SetPoint;
		Val2 := G_EP31Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP31Threshold < 300 THEN
				G_EP31Threshold := G_EP31Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP31Threshold > 50 THEN
				G_EP31Threshold := G_EP31Threshold - 5;
			END_IF
		END_IF

		G_EP31ThresholdSet := TRUE;

	32:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_SetPoint;
		Val2 := G_EP32Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP32Threshold < 300 THEN
				G_EP32Threshold := G_EP32Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP32Threshold > 50 THEN
				G_EP32Threshold := G_EP32Threshold - 5;
			END_IF
		END_IF

		(* Force elev rear fwd with speed 0 *)
		G_EP32ThresholdSet := TRUE;

	35:
		LEDUP := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_SetPoint;
		Val2 := G_EP61Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP61Threshold < 400 THEN
				G_EP61Threshold := G_EP61Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP61Threshold > 50 THEN
				G_EP61Threshold := G_EP61Threshold - 5;
			END_IF
		END_IF

		IF KEY_DOWN_IN THEN
			(* Force elev down with speed 0 *)
			G_EP61ThresholdSet := TRUE;
		END_IF

	37:
		LEDUP := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_SetPoint;
		Val2 := G_EP65Threshold;
		TextL3 := TL_MoveValueToMaximum;
		TextL4 := TL_LowerValueUntilMovementStop;

		IF KEY_RIGHT THEN
			IF G_EP65Threshold < 1000 THEN
				G_EP65Threshold := G_EP65Threshold + 10;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_EP65Threshold > 0 THEN
				G_EP65Threshold := G_EP65Threshold - 5;
			END_IF
		END_IF

		IF KEY_DOWN_IN THEN
			G_EP65ThresholdSet := TRUE;
		END_IF

	40:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;
		B_InvisibleValue3 := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_AircraftDistance;
		 Val3 := W_AircraftDistance;
		TextL4 := TL_Blank;

		IF W_AircraftDistance < 200 THEN
			G_CameraAdjust := TRUE;
		ELSE
			G_CameraAdjust := FALSE;
		END_IF

	42:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_PressOkToSet;

		CASE BY_Mode OF
				0 : TextL4 := TL_ModeNoMode;
					B_ForceDriveMode := FALSE;
					B_ForceLoadMode := FALSE;
					IF KEY_OK THEN
						BY_Mode := BY_Mode +1 ;
					END_IF

				1:   TextL4 := TL_ModeDrive;
					B_ForceDriveMode := TRUE;
					B_ForceLoadMode := FALSE;
					IF KEY_OK THEN
						BY_Mode := BY_Mode +1 ;
					END_IF

				2:   TextL4 := TL_ModeLoad;
					B_ForceDriveMode := FALSE;
					B_ForceLoadMode := TRUE;
					IF KEY_OK THEN
						BY_Mode := 0 ;
					END_IF
		END_CASE

	43:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_SV90ActivatedPressureDemand;
		TextL4 := TL_Blank;

		G_ForcePumpEnable := TRUE;
		G_HighDemandRequest := TRUE;
		B_SV90Bypass := TRUE;

	44:
		LEDUP := FALSE;
		LEDDOWN := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_PressLeftRightToForce;
		TextL4 := TL_Blank;

		IF KEY_LEFT_IN THEN
			G_SideRollerBypassLeft := TRUE;
			G_SideRollerBypassRight := FALSE;
		END_IF

		IF KEY_RIGHT_IN THEN
			G_SideRollerBypassLeft := FALSE;
			G_SideRollerBypassRight := TRUE;
		END_IF

	45:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue3 := FALSE;

		TextL2 := TL_Blank;
		TextL3 := TL_MaximumCurrent;
		Val3 := MAX_Battery_Current;
		TextL4 := TL_Adjust;

		IF KEY_RIGHT THEN
			IF MAX_Battery_Current < 1500 THEN
				MAX_Battery_Current := MAX_Battery_Current + 50;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF MAX_Battery_Current > 100 THEN
				MAX_Battery_Current := MAX_Battery_Current - 50;
			END_IF
		END_IF

	46:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;
		LEDOK := TRUE;
		B_InvisibleValue3 := FALSE;

		TextL2 := TL_PressOkToResetStateOfCharge;
		TextL3 := TL_BatteryStateOfCharge;
		Val3 := G_BatteryLevel;
		TextL4 := TL_Blank;

		IF KEY_OK THEN
			B_ResetSOC := TRUE;
		END_IF


	48:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDOK := TRUE;
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue4 := FALSE;

		TextL2 := TL_PumpMotorRPM;
		Val2 := I_PumpMotorRPM;
		IF G_MotorPumpEnable THEN
			TextL3 := TL_MotorActive;
		ELSE
			TextL3 := TL_MotorInactive;
		END_IF
		TextL4 := TL_PS7_MainPumpPressure;
		Val4 := G_InputsA[CInMainPumpPressure].I_Value;

		IF KEY_RIGHT THEN
			G_MotorPumpEnable := TRUE;
		END_IF

		IF KEY_LEFT THEN
			G_MotorPumpEnable := FALSE;
		END_IF

		IF KEY_OK_IN AND G_MotorPumpEnable THEN
			B_JogPump := TRUE;
		ELSE
			B_JogPump := FALSE;
		END_IF

		B_PumpRotationCheck := TRUE;

	49:
		LEDUP := FALSE;
		LEDDOWN := FALSE;

		TextL2 := TL_Blank;
		IF G_MotorTractionEnable THEN
			TextL3 := TL_MotorActive;
		ELSE
			TextL3 := TL_MotorInactive;
		END_IF
		TextL4 := TL_Blank;

		IF KEY_RIGHT THEN
			G_MotorTractionEnable := TRUE;
		END_IF

		IF KEY_LEFT THEN
			G_MotorTractionEnable := FALSE;
		END_IF
	50:
		LEDUP := FALSE;
		LEDDOWN := FALSE;

		TextL2 := TL_Blank;
		IF G_MotorRegenEnable THEN
			TextL3 := TL_MotorActive;
		ELSE
			TextL3 := TL_MotorInactive;
		END_IF
		TextL4 := TL_Blank;

		IF KEY_RIGHT THEN
			G_MotorRegenEnable := TRUE;
		END_IF

		IF KEY_LEFT THEN
			G_MotorRegenEnable := FALSE;
		END_IF

	51:
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_AutomaticShutownAfter;
		Val2 := G_AutoShutdownTimer;
		TextL3 := TL_MinutesOfIdleTime;
		TextL4 := TL_Adjust;

		IF KEY_RIGHT THEN
			IF G_AutoShutdownTimer < 60 THEN
				G_AutoShutdownTimer := G_AutoShutdownTimer + 1;
			END_IF
		END_IF

		IF KEY_LEFT THEN
			IF G_AutoShutdownTimer > 0 THEN
				G_AutoShutdownTimer := G_AutoShutdownTimer - 1;
			END_IF
		END_IF


	61 :
		B_InvisibleValue2 := FALSE;

		TextL2 := TL_ActualHour;
		Val2 := DWORD_TO_WORD(DW_Hourmeter/60);
		TextL3 := TL_UseTheArrowKeys;
		TextL4 := TL_Blank;

		IF KEY_LEFT THEN
			IF DW_Hourmeter > 0 THEN
				DW_Hourmeter := DW_Hourmeter - 60;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			DW_Hourmeter := DW_Hourmeter + 60;
		END_IF

		IF KEY_UP THEN
			DW_Hourmeter := DW_Hourmeter + 600;
		END_IF

		IF KEY_DOWN THEN
			IF DW_Hourmeter > 9 THEN
				DW_Hourmeter := DW_Hourmeter - 600;
			END_IF
		END_IF
	END_CASE
END_IF




END_ACTION

ACTION	F4_Fault:
IF W_StaticID = TL_FaultLog THEN
	LEDLEFT := FALSE;
	LEDRIGHT := FALSE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDOK := (FaultLogSelectedLine = 0 AND BY_FaultLogEntriesCount > 0) OR
			      (FaultLogSelectedLine = 1 AND BY_MotorFaultCount > 0) OR
			      (FaultLogSelectedLine = 2 AND G_AircraftContactCounter > 0 AND OPT_ASD) OR
				(FaultLogSelectedLine = 3 AND (G_AircraftContactCounter > 0 OR BY_MotorFaultCount > 0 OR BY_FaultLogEntriesCount > 0)) ;
	LEDESC := TRUE;
	B_InvisibleValue1 := FALSE;
	B_InvisibleValue2 := FALSE;
	B_InvisibleValue3 := FALSE;
	B_InvisibleValue4 := TRUE;

	Index := 0;
	BY_FaultLogEntriesCount := 0;
	BY_MotorFaultCount := 0 ;
	WHILE (Index <= MaxIndexFaults) DO
		IF G_FaultOccurence[Index] > 0 THEN
			BY_FaultLogEntriesCount := BY_FaultLogEntriesCount + 1;
		END_IF
		Index := Index + 1;
	END_WHILE
	IF OPT_DCDCSystem AND OPT_LeadAcidBattery THEN
		Index := 0;
		WHILE (Index <= MaxIndexFaultsDCDC) DO
			IF G_FaultOccurenceDCDC[Index] > 0 THEN
				BY_FaultLogEntriesCount := BY_FaultLogEntriesCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
	END_IF
	Index := 0;
	WHILE (Index <= MaxIndexOutputsA) DO
		IF G_FaultOutputsAShort[Index] > 0 OR G_FaultOutputsAOpen[Index] > 0 THEN
			BY_FaultLogEntriesCount := BY_FaultLogEntriesCount + 1;
		END_IF
		Index := Index + 1;
	END_WHILE
	Index := 0;
	WHILE (Index <= MaxIndexOutputsD) DO
		IF G_FaultOutputsDShort[Index] > 0 OR G_FaultOutputsDOpen[Index] > 0 THEN
			BY_FaultLogEntriesCount := BY_FaultLogEntriesCount + 1;
		END_IF
		Index := Index + 1;
	END_WHILE
	IF B_OPT_838 THEN
		Index := 0;
		WHILE (Index <= MaxIndexFaultsCurtisPump) DO
			IF G_FaultOccurenceCurtisPump[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		Index := 0;
		WHILE (Index <= MaxIndexFaultsCurtisTraction) DO
			IF G_FaultOccurenceCurtisTraction[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		Index := 0;
		WHILE (Index <= MaxIndexFaultsCurtisRegen) DO
			IF G_FaultOccurenceCurtisRegen[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
	ELSE (*929*)
		Index := 0;
		WHILE (Index <= MaxIndexFaultsPump) DO
			IF G_FaultOccurencePump[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		Index := 0;
		WHILE (Index <= MaxIndexFaultsTraction) DO
			IF G_FaultOccurenceTraction[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		Index := 0;
		WHILE (Index <= MaxIndexFaultsRegen) DO
			IF G_FaultOccurenceRegen[Index] > 0  THEN
				BY_MotorFaultCount := BY_MotorFaultCount + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
	END_IF

	Val1 := BY_FaultLogEntriesCount;
	Val2 := BY_MotorFaultCount;
	IF OPT_ASD THEN
		Val3 := G_AircraftContactCounter;
	ELSE
		FaultLogTextList[2] := TL_Blank;
		B_InvisibleValue3 := TRUE;
	END_IF

	TextL1 := FaultLogTextList[FaultLogDisplayLine];
	TextL2 := FaultLogTextList[FaultLogDisplayLine + 1];
	TextL3 := FaultLogTextList[FaultLogDisplayLine + 2];
	TextL4 := FaultLogTextList[FaultLogDisplayLine + 3];

	IF KEY_UP THEN
		IF (SelectedLine = 3 AND OPT_ASD) OR SelectedLine = 2 OR SelectedLine = 1 THEN
			SelectedLine := SelectedLine - 1;
		ELSIF (SelectedLine = 3 AND NOT OPT_ASD) THEN
			SelectedLine := SelectedLine - 2;
		END_IF
	END_IF

	IF KEY_DOWN THEN
		IF SelectedLine = 0 OR (SelectedLine = 1 AND OPT_ASD) OR SelectedLine = 2 THEN
			SelectedLine := SelectedLine + 1;
		ELSIF (SelectedLine = 1 AND NOT OPT_ASD) THEN
			SelectedLine := SelectedLine + 2;
		END_IF
	END_IF

	IF KEY_OK THEN
		CASE SelectedLine OF
			0:	(* DISPLAY FaultS *)
				IF BY_FaultLogEntriesCount > 0 THEN
					W_StaticID := TL_DisplayFaults;
					ScanIndexPointer := 0;
					FaultLogDisplayLine := 0;
				END_IF
			1 :
				IF BY_MotorFaultCount > 0 THEN
					W_StaticID := TL_MotorFaults;
					ScanIndexPointer := 0;
					FaultLogDisplayLine := 0;
				END_IF
			2 :
				IF G_AircraftContactCounter > 0 THEN
					W_StaticID := TL_ASDEventLog;
					ScanIndexPointer := 0;
					ScanIndexPointer2 := 0;
					FaultLogDisplayLine := 1;
				END_IF
			3 : (* ERASE ALL ENTRIES *)
				IF BY_FaultLogEntriesCount > 0 OR G_AircraftContactCounter > 0 OR BY_MotorFaultCount > 0 THEN
					W_StaticID := TL_EraseAllEntries;
					ScanIndexPointer := 0;
					FaultLogDisplayLine := 0;
				END_IF
		END_CASE
	END_IF

	IF KEY_ESC THEN
		page_extern := 2; (*MAIN PAGE*)
		FaultLogSelectedLine := 0;
		FaultLogDisplayLine := 0;
		SelectedLine := 0;
	END_IF

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF

ELSIF W_StaticID = TL_DisplayFaults OR W_StaticID = TL_MotorFaults OR W_StaticID = TL_ASDEventLog OR W_StaticID = TL_EraseAllEntries THEN
	LEDESC := TRUE;
	LEDOK := FALSE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;

	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;

	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := FALSE;
	B_InvisibleValue4 := TRUE;

	CASE SelectedLine OF
	0:		(* Faults list *)

		(* Scan list of Faults *)
		(* 0-99 : GENERAL FaultS, 99-198: DCDC FaultS, 198-328: OUTPUTSD FaultS, 329-359: OUTPUTSA FaultS *)
		ScanIndexPointer2 := 0;
		Index := 0;
		WHILE (Index <= MaxIndexFaults) DO
			IF G_FaultOccurence[Index] > 0 THEN
				ScanIndex[ScanIndexPointer2] := Index;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		IF OPT_DCDCSystem AND OPT_LeadAcidBattery THEN
			Index := 0;
			WHILE (Index <= MaxIndexFaultsDCDC) DO
				IF G_FaultOccurenceDCDC[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaults;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
		END_IF
		Index := 0;
		WHILE (Index <= MaxIndexOutputsD) DO
			IF G_FaultOutputsDShort[Index] > 0 OR G_FaultOutputsDOpen[Index] > 0 THEN
				ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaults + MaxIndexFaultsDCDC;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE

		Index := 0;
		WHILE (Index <= MaxIndexOutputsA) DO
			IF G_FaultOutputsAShort[Index] > 0 OR G_FaultOutputsAOpen[Index] > 0 THEN
				ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaults + MaxIndexFaultsDCDC + MaxIndexOutputsD;
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			Index := Index + 1;
		END_WHILE
		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax) THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax;
			END_IF
		END_IF

		IF ScanIndex[ScanIndexPointer] < MaxIndexFaults THEN
			TextL1 := G_FaultFlags[ScanIndex[ScanIndexPointer]].S_Name;
			TextL2 := G_FaultFlags[ScanIndex[ScanIndexPointer]].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurence[ScanIndex[ScanIndexPointer]];
			IF G_FaultFlags[ScanIndex[ScanIndexPointer]].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaults + MaxIndexFaultsDCDC THEN
			index := MaxIndexFaults;
			TextL1 := G_FaultFlagsDCDC[ScanIndex[ScanIndexPointer]-index].S_Name;
			TextL2 := G_FaultFlagsDCDC[ScanIndex[ScanIndexPointer]-index].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceDCDC[ScanIndex[ScanIndexPointer]-index];
			IF G_FaultFlagsDCDC[ScanIndex[ScanIndexPointer]-index].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaults + MaxIndexFaultsDCDC + MaxIndexOutputsD THEN
			index := MaxIndexFaults + MaxIndexFaultsDCDC;
			TextL1 := G_OutputsD[ScanIndex[ScanIndexPointer]-index].S_Name;
			IF G_FaultOutputsDShort[ScanIndex[ScanIndexPointer]-index] > 0 AND G_FaultOutputsDOpen[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				IF T5s THEN
					TextL2 := TL_OutputShort;
					TextL3 := TL_Occurrence;
					Val3 := G_FaultOutputsDShort[ScanIndex[ScanIndexPointer]-index];
					IF G_OutputsD[ScanIndex[ScanIndexPointer]-index].B_Open THEN
						TextL4 := TL_FaultActiveTrue;
					ELSE
						TextL4 := TL_FaultActiveFalse;
					END_IF
				ELSE
					TextL2 := TL_OutputOpen;
					TextL3 := TL_Occurrence;
					Val3 := G_FaultOutputsDOpen[ScanIndex[ScanIndexPointer]-index];
					IF G_OutputsD[ScanIndex[ScanIndexPointer]-index].B_Open THEN
						TextL4 := TL_FaultActiveTrue;
					ELSE
						TextL4 := TL_FaultActiveFalse;
					END_IF
				END_IF
			ELSIF G_FaultOutputsDShort[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				TextL2 := TL_OutputShort;
				TextL3 := TL_Occurrence;
				Val3 := G_FaultOutputsDShort[ScanIndex[ScanIndexPointer]-index];
				IF G_OutputsD[ScanIndex[ScanIndexPointer]-index].B_Short THEN
					TextL4 := TL_FaultActiveTrue;
				ELSE
					TextL4 := TL_FaultActiveFalse;
				END_IF
			ELSIF G_FaultOutputsDOpen[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				TextL2 := TL_OutputOpen;
				TextL3 := TL_Occurrence;
				Val3 := G_FaultOutputsDOpen[ScanIndex[ScanIndexPointer]-index];
				IF G_OutputsD[ScanIndex[ScanIndexPointer]-index].B_Open THEN
					TextL4 := TL_FaultActiveTrue;
				ELSE
					TextL4 := TL_FaultActiveFalse;
				END_IF
			END_IF
		ELSE
			index := MaxIndexFaults + MaxIndexFaultsDCDC + MaxIndexOutputsD;
			TextL1 := G_OutputsA[ScanIndex[ScanIndexPointer]-index].S_Name;
			IF G_FaultOutputsAShort[ScanIndex[ScanIndexPointer]-index] > 0 AND G_FaultOutputsAOpen[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				IF T5s THEN
					TextL2 := TL_OutputShort;
					TextL3 := TL_Occurrence;
					Val3 := G_FaultOutputsAShort[ScanIndex[ScanIndexPointer]-index];
					IF G_OutputsA[ScanIndex[ScanIndexPointer]-index].B_Short THEN
						TextL4 := TL_FaultActiveTrue;
					ELSE
						TextL4 := TL_FaultActiveFalse;
					END_IF
				ELSE
					TextL2 := TL_OutputOpen;
					TextL3 := TL_Occurrence;
					Val3 := G_FaultOutputsAOpen[ScanIndex[ScanIndexPointer]-index];
					IF G_OutputsA[ScanIndex[ScanIndexPointer]-index].B_Open THEN
						TextL4 := TL_FaultActiveTrue;
					ELSE
						TextL4 := TL_FaultActiveFalse;
					END_IF
				END_IF
			ELSIF G_FaultOutputsAShort[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				TextL2 := TL_OutputShort;
				TextL3 := TL_Occurrence;
				Val3 := G_FaultOutputsAShort[ScanIndex[ScanIndexPointer]-index];
				IF G_OutputsA[ScanIndex[ScanIndexPointer]-index].B_Short THEN
					TextL4 := TL_FaultActiveTrue;
				ELSE
					TextL4 := TL_FaultActiveFalse;
				END_IF
			ELSIF G_FaultOutputsAOpen[ScanIndex[ScanIndexPointer]-index] > 0 THEN
				TextL2 := TL_OutputOpen;
				TextL3 := TL_Occurrence;
				Val3 := G_FaultOutputsAOpen[ScanIndex[ScanIndexPointer]-index];
				IF G_OutputsA[ScanIndex[ScanIndexPointer]-index].B_Open THEN
					TextL4 := TL_FaultActiveTrue;
				ELSE
					TextL4 := TL_FaultActiveFalse;
				END_IF
			END_IF
		END_IF

		IF KEY_ESC THEN
			W_StaticID := TL_FaultLog;
			SelectedLine := 0;
			FaultLogSelectedLine := 0;
			FaultLogDisplayLine := 0;
		END_IF

	1:		(* Motors  Faults list *)

		ScanIndexPointer2 := 0;
		IF B_OPT_838 THEN
			Index := 0;
			WHILE (Index <= MaxIndexFaultsCurtisPump) DO
				IF G_FaultOccurenceCurtisPump[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
	
			Index := 0;
			WHILE (Index <= MaxIndexFaultsCurtisTraction) DO
				IF G_FaultOccurenceCurtisTraction[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaultsCurtisPump;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
	
			Index := 0;
			WHILE (Index <= MaxIndexFaultsCurtisRegen) DO
				IF G_FaultOccurenceCurtisRegen[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaultsCurtisPump + MaxIndexFaultsCurtisTraction ;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
		ELSE (*929*)
			Index := 0;
			WHILE (Index <= MaxIndexFaultsPump) DO
				IF G_FaultOccurencePump[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
	
			Index := 0;
			WHILE (Index <= MaxIndexFaultsTraction) DO
				IF G_FaultOccurenceTraction[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaultsPump;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
	
			Index := 0;
			WHILE (Index <= MaxIndexFaultsRegen) DO
				IF G_FaultOccurenceRegen[Index] > 0 THEN
					ScanIndex[ScanIndexPointer2] := Index + MaxIndexFaultsPump + MaxIndexFaultsTraction;
					ScanIndexPointer2 := ScanIndexPointer2 + 1;
				END_IF
				Index := Index + 1;
			END_WHILE
		END_IF

		ScanIndexMax := ScanIndexPointer2 - 1;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax) THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax;
			END_IF
		END_IF
	IF B_OPT_838 THEN
		IF ScanIndex[ScanIndexPointer] < MaxIndexFaultsCurtisPump THEN
			TextL1 := G_FaultFlagsCurtisPump[ScanIndex[ScanIndexPointer]].S_Name;
			TextL2 := G_FaultFlagsCurtisPump[ScanIndex[ScanIndexPointer]].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceCurtisPump[ScanIndex[ScanIndexPointer]];
			IF G_FaultFlagsCurtisPump[ScanIndex[ScanIndexPointer]].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaultsCurtisPump + MaxIndexFaultsCurtisTraction THEN
			index := MaxIndexFaultsCurtisPump;
			TextL1 := G_FaultFlagsCurtisTraction[ScanIndex[ScanIndexPointer]-index].S_Name;
			TextL2 := G_FaultFlagsCurtisTraction[ScanIndex[ScanIndexPointer]-index].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceCurtisTraction[ScanIndex[ScanIndexPointer]-index];
			IF G_FaultFlagsCurtisTraction[ScanIndex[ScanIndexPointer]-index].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaultsCurtisPump + MaxIndexFaultsCurtisTraction + MaxIndexFaultsCurtisRegen THEN
			index := MaxIndexFaultsCurtisPump + MaxIndexFaultsCurtisTraction ;
			TextL1 := G_FaultFlagsCurtisRegen[ScanIndex[ScanIndexPointer]-index].S_Name;
			TextL2 := G_FaultFlagsCurtisRegen[ScanIndex[ScanIndexPointer]-index].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceCurtisRegen[ScanIndex[ScanIndexPointer]-index];
			IF G_FaultFlagsCurtisRegen[ScanIndex[ScanIndexPointer]-index].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		END_IF
	ELSE (*929*)
		IF ScanIndex[ScanIndexPointer] < MaxIndexFaultsPump THEN
			TextL1 := G_FaultFlagsPump[ScanIndex[ScanIndexPointer]].S_Name;
			TextL2 := G_FaultFlagsPump[ScanIndex[ScanIndexPointer]].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurencePump[ScanIndex[ScanIndexPointer]];
			IF G_FaultFlagsPump[ScanIndex[ScanIndexPointer]].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaultsPump + MaxIndexFaultsTraction THEN
			index := MaxIndexFaultsPump;
			TextL1 := G_FaultFlagsTraction[ScanIndex[ScanIndexPointer]-index].S_Name;
			TextL2 := G_FaultFlagsTraction[ScanIndex[ScanIndexPointer]-index].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceTraction[ScanIndex[ScanIndexPointer]-index];
			IF G_FaultFlagsTraction[ScanIndex[ScanIndexPointer]-index].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		ELSIF ScanIndex[ScanIndexPointer] < MaxIndexFaultsPump + MaxIndexFaultsTraction + MaxIndexFaultsRegen THEN
			index := MaxIndexFaultsPump + MaxIndexFaultsTraction ;
			TextL1 := G_FaultFlagsRegen[ScanIndex[ScanIndexPointer]-index].S_Name;
			TextL2 := G_FaultFlagsRegen[ScanIndex[ScanIndexPointer]-index].S_Description;
			TextL3 := TL_Occurrence;
			Val3 := G_FaultOccurenceRegen[ScanIndex[ScanIndexPointer]-index];
			IF G_FaultFlagsRegen[ScanIndex[ScanIndexPointer]-index].B_Active THEN
				TextL4 := TL_FaultActiveTrue;
			ELSE
				TextL4 := TL_FaultActiveFalse;
			END_IF
		END_IF
	END_IF


		IF KEY_ESC THEN
			W_StaticID := TL_FaultLog;
			SelectedLine := 0;
			FaultLogSelectedLine := 0;
			FaultLogDisplayLine := 0;
		END_IF

	2: (*ASD Event*)

		B_InvisibleValue1 := FALSE;
		B_InvisibleValue2 := FALSE;
		B_InvisibleValue3 := FALSE;
		B_InvisibleValue4 := FALSE;

		Index := 0;

		IF G_AircraftContactCounter > 0 THEN
			ScanIndexMax := G_AircraftContactCounter - 1;
		ELSE
			ScanIndexMax := 0;
		END_IF

		IF FaultLogDisplayLine = 1 THEN
			FrameColorL1 := FALSE;
			FrameColorL2 := TRUE;
			FrameColorL3 := FALSE;
			FrameColorL4 := FALSE;
		ELSIF FaultLogDisplayLine = 2 THEN
			FrameColorL1 := FALSE;
			FrameColorL2 := FALSE;
			FrameColorL3 := TRUE;
			FrameColorL4 := FALSE;
		ELSIF FaultLogDisplayLine = 3 THEN
			FrameColorL1 := FALSE;
			FrameColorL2 := FALSE;
			FrameColorL3 := FALSE;
			FrameColorL4 := TRUE;
		END_IF

		IF KEY_LEFT THEN
			ScanIndexPointer2 := 0;
			FaultLogDisplayLine := 1;
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
				B_ASDLoaded := FALSE;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			ScanIndexPointer2 := 0;
			FaultLogDisplayLine := 1;
			IF (ScanIndexPointer < ScanIndexMax) THEN
				ScanIndexPointer := ScanIndexPointer + 1;
				B_ASDLoaded := FALSE;
			ELSE
				ScanIndexPointer := ScanIndexMax;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF (ScanIndexPointer2 > 0) AND FaultLogDisplayLine = 1 THEN
				ScanIndexPointer2 := ScanIndexPointer2 - 1;
			END_IF
			IF FaultLogDisplayLine > 1 THEN
				FaultLogDisplayLine := FaultLogDisplayLine -1;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF (ScanIndexPointer2 < B_ASDFaultsIndex - 3) AND FaultLogDisplayLine = 3  THEN
				ScanIndexPointer2 := ScanIndexPointer2 + 1;
			END_IF
			IF FaultLogDisplayLine < 3 THEN
				FaultLogDisplayLine := FaultLogDisplayLine +1;
			END_IF
		END_IF

		(* AircraftContact in an array of string for simpler display method *)
		IF NOT B_ASDLoaded THEN
			S_ASDFaultsIndex[0] := TL_Hourmeter;
			S_ASDFaultsIndexValue[0] := G_ASDFaults[ScanIndexPointer].W_HourMeter;
			S_ASDFaultsIndex[1] := TL_AircraftDistance;
			S_ASDFaultsIndexValue[1] := G_ASDFaults[ScanIndexPointer].W_AircraftDistance;
			S_ASDFaultsIndex[2] := TL_DriveSpeed;
			S_ASDFaultsIndexValue[2] := G_ASDFaults[ScanIndexPointer].W_Speed;
			S_ASDFaultsIndex[3] := TL_SpeedSensorFault;
			S_ASDFaultsIndexValue[3] := BOOL_TO_WORD(G_ASDFaults[ScanIndexPointer].B_SpeedSensorFaults);
			IF G_ASDFaults[ScanIndexPointer].BY_DriveDirection = 0 THEN (*0 = FWD, 1= REV, 2=NEUTRAL *)
				S_ASDFaultsIndex[4] := TL_DriveDirectionForward;
			ELSIF G_ASDFaults[ScanIndexPointer].BY_DriveDirection = 1 THEN
				S_ASDFaultsIndex[4] := TL_DriveDirectionReverse;
			ELSE
				S_ASDFaultsIndex[4] := TL_DriveDirectionNeutral;
			END_IF
			S_ASDFaultsIndex[5] := TL_BridgeSensitiveBumper;
			S_ASDFaultsIndexValue[5] := BOOL_TO_WORD(G_ASDFaults[ScanIndexPointer].B_SensitiveBumper);
			S_ASDFaultsIndex[6] := TL_LeftHandrailSensitiveBumper;
			S_ASDFaultsIndexValue[6] := BOOL_TO_WORD(G_ASDFaults[ScanIndexPointer].B_LeftHandSensBump);
			S_ASDFaultsIndex[7] := TL_RightHandrailSensitiveBumper;
			S_ASDFaultsIndexValue[7] := BOOL_TO_WORD(G_ASDFaults[ScanIndexPointer].B_RightHandSensBump);
			B_ASDLoaded := TRUE;
		END_IF

		TextL1 := TL_AircraftContact;
		Val1:= ScanIndexPointer + 1 ;
		IF ScanIndexPointer2 = 4 THEN
			B_InvisibleValue2 := TRUE;
		END_IF
		IF ScanIndexPointer2+1 = 4 THEN
			B_InvisibleValue3 := TRUE;
		END_IF
		IF ScanIndexPointer2+2 = 4 THEN
			B_InvisibleValue4 := TRUE;
		END_IF
		TextL2 := S_ASDFaultsIndex[ScanIndexPointer2];
		Val2 := S_ASDFaultsIndexValue[ScanIndexPointer2];
		TextL3 := S_ASDFaultsIndex[ScanIndexPointer2+1];
		Val3 := S_ASDFaultsIndexValue[ScanIndexPointer2+1];
		TextL4 := S_ASDFaultsIndex[ScanIndexPointer2+2];
		Val4 := S_ASDFaultsIndexValue[ScanIndexPointer2+2];

		IF KEY_ESC THEN
			W_StaticID := TL_FaultLog;
			SelectedLine := 0;
			FaultLogSelectedLine := 0;
			FaultLogDisplayLine := 0;
			ScanIndexPointer2 := 0;
		END_IF

	3:		(* Erase all Faults entries *)
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;
		LEDUP := FALSE;
		LEDDOWN := FALSE;
		LEDOK := TRUE;
		LEDESC := TRUE;

		TextL1 := TL_Blank;
		TextL2 := TL_AllEntriesWillBeErased;
		TextL3 := TL_Blank;
		TextL4 := TL_PressOkToConfirm;

		IF KEY_OK THEN
			(* Scan list of Faults *)
			G_AircraftContactCounter := 0;
			Index := 0;
			WHILE (Index <= MaxIndexFaults) DO
				IF NOT G_FaultFlags[Index].B_Active THEN
					G_FaultOccurence[Index] := 0;
				END_IF
				Index := Index + 1;
			END_WHILE
			IF OPT_DCDCSystem AND OPT_LeadAcidBattery THEN
				Index := 0;
				WHILE (Index <= MaxIndexFaultsDCDC) DO
					IF NOT G_FaultFlagsDCDC[Index].B_Active THEN
						G_FaultOccurenceDCDC[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
			END_IF
			Index := 0;
			WHILE (Index <= MaxIndexOutputsA) DO
				G_FaultOutputsAShort[Index] := 0;
				G_FaultOutputsAOpen[Index] := 0;
				Index := Index + 1;
			END_WHILE
			Index := 0;
			WHILE (Index <= MaxIndexOutputsD) DO
				G_FaultOutputsDShort[Index] := 0;
				G_FaultOutputsDOpen[Index] := 0;
				Index := Index + 1;
			END_WHILE
			IF B_OPT_838 THEN
				Index := 0;
				WHILE (Index <= MaxIndexFaultsCurtisPump) DO
					IF NOT G_FaultFlagsCurtisPump[Index].B_Active THEN
						G_FaultOccurenceCurtisPump[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
				Index := 0;
				WHILE (Index <= MaxIndexFaultsCurtisTraction) DO
					IF NOT G_FaultFlagsCurtisTraction[Index].B_Active THEN
						G_FaultOccurenceCurtisTraction[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
					Index := 0;
				WHILE (Index <= MaxIndexFaultsCurtisRegen) DO
					IF NOT G_FaultFlagsCurtisRegen[Index].B_Active THEN
						G_FaultOccurenceCurtisRegen[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
			ELSE (*929*)
				Index := 0;
				WHILE (Index <= MaxIndexFaultsPump) DO
					IF NOT G_FaultFlagsPump[Index].B_Active THEN
						G_FaultOccurencePump[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
				Index := 0;
				WHILE (Index <= MaxIndexFaultsTraction) DO
					IF NOT G_FaultFlagsTraction[Index].B_Active THEN
						G_FaultOccurenceTraction[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
					Index := 0;
				WHILE (Index <= MaxIndexFaultsRegen) DO
					IF NOT G_FaultFlagsRegen[Index].B_Active THEN
						G_FaultOccurenceRegen[Index] := 0;
					END_IF
					Index := Index + 1;
				END_WHILE
			END_IF


			W_StaticID := TL_FaultLog;
			SelectedLine := 0;
			FaultLogSelectedLine := 0;
			FaultLogDisplayLine := 0;

			G_DCDC_clear_all_faults := TRUE;
		END_IF

		IF KEY_ESC THEN
			W_StaticID := TL_FaultLog;
			SelectedLine := 0;
			FaultLogSelectedLine := 0;
			FaultLogDisplayLine := 0;
		END_IF
	END_CASE
END_IF
END_ACTION

ACTION	F5_Information:
IF W_StaticID = TL_Information THEN
	LEDLEFT := FALSE;
	LEDRIGHT := FALSE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDOK := TRUE;
	LEDESC := TRUE;

	B_InvisibleValue1 := TRUE;
	B_InvisibleValue2 := TRUE;
	B_InvisibleValue3 := TRUE;
	B_InvisibleValue4 := TRUE;

	TextL1 := InformationTextList[InformationDisplayLine];
	TextL2 := InformationTextList[InformationDisplayLine + 1];
	TextL3 := InformationTextList[InformationDisplayLine + 2];
	TextL4 := InformationTextList[InformationDisplayLine + 3];

	IF KEY_UP THEN
		IF InformationSelectedLine > 0 THEN
			InformationSelectedLine := InformationSelectedLine - 1;
			IF SelectedLine = 0 THEN
				InformationSelectedLine := InformationSelectedLine - 1;
			ELSE
				SelectedLine := SelectedLine - 1;
			END_IF
		ELSE
			InformationSelectedLine := 0;
			InformationDisplayLine := 0;
			SelectedLine := 0;
		END_IF
	END_IF

	IF KEY_DOWN THEN
		IF NOT (InformationTextList[InformationSelectedLine+1] = 0) THEN
			InformationSelectedLine := InformationSelectedLine + 1;
			IF SelectedLine = 3 THEN
				InformationSelectedLine := InformationSelectedLine + 1;
			ELSE
				SelectedLine := SelectedLine + 1;
			END_IF
		END_IF
	END_IF


	IF KEY_OK THEN
		CASE InformationSelectedLine OF
			0:	(* ENGINE INFORMATION *)
				W_StaticID := TL_Motors;
				InformationDisplayLine := 0;
				SelectedLine := 0;
				ScanIndexPointer := 0;
			1 :	(* SYSTEM STATUS *)
				W_StaticID := TL_SystemStatus;
				InformationDisplayLine := 0;
				SelectedLine := 0;
				ScanIndexPointer := 0;
			2 :	(* HISTORY *)
				W_StaticID := TL_History;
				InformationDisplayLine := 0;
				SelectedLine := 0;
				ScanIndexPointer := 0;
			3 :	(* VERSION *)
				W_StaticID := TL_Version;
				InformationDisplayLine := 0;
				SelectedLine := 0;
				ScanIndexPointer := 0;
		END_CASE
	END_IF


	IF KEY_ESC THEN
		page_extern := 2; (*MAIN PAGE*)
		InformationSelectedLine := 0;
		InformationDisplayLine := 0;
		SelectedLine := 0;
	END_IF

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF

ELSIF 	W_StaticID = TL_Motors OR  	W_StaticID = TL_SystemStatus OR W_StaticID = TL_History OR W_StaticID = TL_Version  THEN
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDOK := FALSE;
	LEDESC := TRUE;

	B_InvisibleValue1 := FALSE;
	B_InvisibleValue2 := FALSE;
	B_InvisibleValue3 := FALSE;
	B_InvisibleValue4 := FALSE;

	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;

	CASE InformationSelectedLine OF
	0:		(* Engine information *)

		IF B_OPT_929 THEN
			ScanIndexMax := 17;
		ELSE
			ScanIndexMax := 14;
		END_IF

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		(* Engine parameters list, display the right values *)
		index := 0;
 		WHILE index <= ScanIndexPointer DO
			(* Shift lines to be displayed *)
			IF index > 0 THEN
				TextL1 := TextL2;
				Val1 := Val2;
				TextL2 := TextL3;
				Val2 := Val3;
				TextL3 := TextL4;
				Val3 := Val4;
			END_IF

			CASE index OF
			0:
				TextL1 := TL_PumpMotorRPM;
				Val1 := I_PumpMotorRPM;
				TextL2 := TL_TractionMotorRPM;
				Val2 :=I_TractionMotorRPM;
				TextL3 := TL_RegenMotorRPM;
				Val3 := I_RegenMotorRPM;
				TextL4 := TL_PumpMotorVoltage;
				Val4 := W_PumpControllerVoltage;
			1:
				TextL4 := TL_TractionMotorVoltage;
				Val4 := W_TractionControllerVoltage;
			2:
				TextL4 := TL_RegenMotorVoltage;
				Val4 := W_RegenControllerVoltage;
			3:
				TextL4 := TL_PumpMotorAmpere;
				Val4 := I_PumpControllerCurrent;
			4:
				TextL4 := TL_TractionMotorAmpere;
				Val4 := I_TractionControllerCurrent;
			5:
				TextL4 := TL_RegenMotorAmpere;
				Val4 := I_RegenControllerCurrent;
			6:
				TextL4 := TL_PumpMotorTemperature;
				Val4 := INT_TO_WORD(I_PumpMotorTemp);
			7:
				TextL4 := TL_TractionMotorTemperature;
				Val4 := INT_TO_WORD(I_TractionMotorTemp);
			8:
				TextL4 := TL_RegenMotorTemperature;
				Val4 := INT_TO_WORD(I_RegenMotorTemp );
			9:
				IF B_OPT_838 THEN
					TextL4 := TL_PumpControllerTemperature;
					Val4 := INT_TO_WORD(I_PumpControllerTemp);
				ELSE (*929*)
					TextL4 := TL_PumpControllerTemperaturePCB;
					Val4 := INT_TO_WORD(I_PumpControllerTempPCB);
				END_IF
			10:
				IF B_OPT_838 THEN
					TextL4 := TL_TractionControllerTemperature;
					Val4 := INT_TO_WORD(I_TractionControllerTemp);
				ELSE (*929*)
					TextL4 := TL_TractionControllerTemperaturePCB;
					Val4 := INT_TO_WORD(I_TractionControllerTempPCB);
				END_IF
			11:
				IF B_OPT_838 THEN
					TextL4 := TL_RegenControllerTemperature;
					Val4 := INT_TO_WORD(I_RegenControllerTemp);
				ELSE (*929*)
					TextL4 := TL_RegenControllerTemperaturePCB;
					Val4 := INT_TO_WORD(I_RegenControllerTempPCB);
				END_IF
			12:
				TextL4 := TL_PumpControllerTemperaturePowerStage;
				Val4 := INT_TO_WORD(I_PumpControllerTempPowerStage);
			13:
				TextL4 := TL_TractionControllerTemperaturePowerStage;
				Val4 := INT_TO_WORD(I_TractionControllerTempPowerStage);
			14:
				TextL4 := TL_RegenControllerTemperaturePowerStage;
				Val4 := INT_TO_WORD(I_RegenControllerTempPowerStage);
			END_CASE

			(* Increment index until last line *)
			index := index + 1;
		END_WHILE

		IF KEY_ESC THEN
			W_StaticID := TL_Information;
			SelectedLine := 0;
			InformationSelectedLine := 0;
			InformationDisplayLine := 0;
		END_IF

	1:		(* SYSTEM STATUS *)
		B_InvisibleValue1 := TRUE;
		B_InvisibleValue2 := TRUE;
		B_InvisibleValue3 := TRUE;
		B_InvisibleValue4 := TRUE;

		ScanIndexMax := 8;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		(* System variables list, display the right values *)
		index := 0;
 		WHILE index <= ScanIndexPointer DO
			(* Shift lines to be displayed *)
			IF index > 0 THEN
				TextL1 := TextL2;
				Val1 := Val2;
				TextL2 := TextL3;
				Val2 := Val3;
				TextL3 := TextL4;
				Val3 := Val4;
			END_IF

			CASE index OF
			0:
				B_InvisibleValue1 := FALSE;

				TextL1 := TL_BatteryStateOfCharge;
				Val1 := G_BatteryLevel;

				IF G_LoadMode THEN
					TextL2 := TL_ModeLoad;
				ELSIF G_DriveMode THEN
					TextL2 := TL_ModeDrive;
				ELSE
					TextL2 := TL_ModeNoMode;
				END_IF
				IF G_StraddleInterlockEngaged THEN
					TextL3 := TL_StraddleEngaged;
				ELSE
					TextL3 := TL_StraddleNotEngaged;
				END_IF
				IF (G_InputsD[CInRearStopUpSensor].B_Value AND G_FaultFlags[GE_RearStopSensorFault].B_Active)
				  OR G_InputsD[CInElevatorNearFrame].B_Value OR G_InputsD[CInElevatorAtFrame].B_Value
				  OR G_InputsD[CInElevatorBelow60In].B_Value THEN
					TextL4 := TL_RearStopInterlockOff;
				ELSE
					TextL4 := TL_RearStopInterlockOn;
				END_IF

			1:	B_InvisibleValue4 := FALSE;

				TextL4 := TL_ElevatorUpSpeed;
				Val4 := W_LiftUpSpeed/10;

			2: 	B_InvisibleValue3 := FALSE;

				IF NOT G_FaultFlags[GE_HydLowPressure].B_Active THEN
					TextL4 := TL_HydraulicOilPressureOk;
				ELSE
					TextL4 := TL_HydraulicOilPressureLow;
				END_IF

			3: 	B_InvisibleValue2 := FALSE;
				IF NOT OPT_LowHydShutdown THEN
					TextL4 := TL_HydraulicOilLevelNA;
				ELSIF Chassis.G_HydOilLevelOK THEN
					TextL4 := TL_HydraulicOilLevelOK;
				ELSE
					TextL4 := TL_HydraulicOilLevelLow;
				END_IF

			4: 	B_InvisibleValue1 := FALSE;
				IF Chassis.G_NeutralForStartOK THEN
					TextL4 := TL_DriveNeutralPositionOK;
				ELSE
					TextL4 := TL_NoStartNotInNeutral;
				END_IF

			5:	B_InvisibleValue4 := FALSE;
				TextL4 := TL_PumpPressureRequest;
				Val4 := G_OutputsA[CPWMMainPumpPressureEP3].I_Value;
			END_CASE

			(* Increment index until last line *)
			index := index + 1;
		END_WHILE

		IF KEY_ESC THEN
			W_StaticID := TL_Information;
			SelectedLine := 0;
			InformationSelectedLine := 0;
			InformationDisplayLine := 0;
		END_IF


	2:		(* HISTORY *)
		ScanIndexMax := 10;

		IF KEY_LEFT THEN
			IF ScanIndexPointer > MaxLines - 1 THEN
				ScanIndexPointer := ScanIndexPointer - MaxLines;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_RIGHT THEN
			IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
				ScanIndexPointer := ScanIndexPointer + MaxLines;
			ELSE
				ScanIndexPointer := ScanIndexMax - MaxLines + 1;
			END_IF
		END_IF

		IF KEY_UP THEN
			IF ScanIndexPointer > 0 THEN
				ScanIndexPointer := ScanIndexPointer - 1;
			ELSE
				ScanIndexPointer := 0;
			END_IF
		END_IF

		IF KEY_DOWN THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		END_IF

		(* Counters list, display the right values *)
		index := 0;
 		WHILE index <= ScanIndexPointer DO
			(* Shift lines to be displayed *)
			IF index > 0 THEN
				TextL1 := TextL2;
				Val1 := Val2;
				TextL2 := TextL3;
				Val2 := Val3;
				TextL3 := TextL4;
				Val3 := Val4;
			END_IF

			CASE index OF
			0:
				TextL1 := TL_LoaderStart;
				Val1 := DWORD_TO_WORD(DW_EngineStarts);
				TextL2 := TL_Hourmeter;
				Val2 := DWORD_TO_WORD(DW_Hourmeter/60);
				TextL3 := TL_PumpMotorHourmeter;
				Val3 := DWORD_TO_WORD(DW_PumpMotorHours/60);
				TextL4 := TL_TractionMotorHourmeter;
				Val4 := DWORD_TO_WORD(DW_TractionMotorHours/60);
			1:
				TextL4 := TL_RegenMotorHourmeter;
				Val4 := DWORD_TO_WORD(DW_RegenMotorHours/60);
			2:
				TextL4 := TL_ElevatorCycles;
				Val4 := DWORD_TO_WORD(DW_ElevatorCycles/100);
			3:
				TextL4 := TL_Odometer;
				Val4 := REAL_TO_WORD(DW_Odometer/10);
			4:
				TextL4 := TL_BrakeApplied;
				Val4 := DWORD_TO_WORD(DW_BrakeApplied/100);
			5:
				TextL4 := TL_TotalEnergy;
				Val4 := REAL_TO_WORD(History.EnergyTotal);
			6:
				TextL4 := TL_BridgeCycles;
				Val4 := DWORD_TO_WORD(DW_BridgeCycles/100);
			7:
				TextL4 := TL_BatteryCycles;
				Val4 := DWORD_TO_WORD(G_NumberBatteryCycle);

			8: 	TextL4 := TL_BatteryShutdown;
				Val4 :=  BYTE_TO_WORD(BY_BatteryShutdown);

			END_CASE

			(* Increment index until last line *)
			index := index + 1;
		END_WHILE

		IF KEY_ESC THEN
			W_StaticID := TL_Information;
			SelectedLine := 0;
			InformationSelectedLine := 0;
			InformationDisplayLine := 0;
		END_IF


	3:		(* VERSION *)
		LEDLEFT := FALSE;
		LEDRIGHT := FALSE;
		LEDUP := FALSE;
		LEDDOWN := FALSE;

		B_InvisibleValue1 := TRUE;
		B_InvisibleValue2 := TRUE;
		B_InvisibleValue3 := TRUE;
		B_InvisibleValue4 := TRUE;

		(* Display program version *)
		TextL1 := TL_MainController;
		TextL2 := TL_Blank;
		Val1 := DWORD_TO_WORD(S_Program);
		Val2 := DWORD_TO_WORD(SHR(S_Program, 16));
		Val3 := S_Version;

		TextL3 := TL_DiagnosticCenter;
		TextL4 := TL_Blank;

		IF KEY_ESC THEN
			W_StaticID := TL_Information;
			SelectedLine := 0;
			InformationSelectedLine := 0;
			InformationDisplayLine := 0;
		END_IF
	END_CASE
END_IF
END_ACTION

ACTION	LoadTestCode:
CASE BY_LoadTestCode OF
			0:
				IF KEY_UP THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_LEFT OR KEY_DOWN OR KEY_RIGHT  OR F1 OR F2 OR F3 OR F4 THEN
					BY_LoadTestCode := 0;
				END_IF
			1:
				IF KEY_DOWN THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			2:
				IF KEY_UP THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_LEFT  OR KEY_DOWN OR KEY_RIGHT OR F1 OR F2 OR F3 OR F4 THEN
					BY_LoadTestCode := 0;
				END_IF
			3:
				IF KEY_DOWN THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_UP OR KEY_RIGHT OR KEY_LEFT OR F1 OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			4:
				IF KEY_LEFT THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF  KEY_UP OR KEY_DOWN OR KEY_RIGHT OR F1 OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			5:
				IF KEY_RIGHT THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			6:
				IF KEY_LEFT THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_UP OR F1 OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF

			7:
				IF KEY_RIGHT THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F3 OR F4 THEN
					BY_LoadTestCode := 0;
				END_IF

			8:
				IF F1 THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF

			9:
				IF F2 THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF

			10:
				IF F1 THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F2 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			11:
				IF F2 THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F3 OR F4  THEN
					BY_LoadTestCode := 0;
				END_IF
			12:
				IF F3 THEN
					BY_LoadTestCode := BY_LoadTestCode+1;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F4 THEN
					BY_LoadTestCode := 0;
				END_IF
			13:
				IF F4 THEN
					B_LoadTestOK := TRUE;
				ELSIF KEY_RIGHT OR KEY_DOWN OR KEY_LEFT OR KEY_UP OR F1 OR F2 OR F3  THEN
					BY_LoadTestCode := 0;
				END_IF
END_CASE

RT_Cycles(CLK:= B_LoadTestOK , Q=> );
IF RT_Cycles.Q THEN
	DW_LoadTestCycle := DW_ElevatorCycles;
END_IF

IF B_LoadTestOK THEN

	W_StaticID := TL_Blank;

	FrameColorL1 := FALSE;
	FrameColorL2 := FALSE;
	FrameColorL3 := FALSE;
	FrameColorL4 := FALSE;

	IF DiagnosticCheck.FaultActive  THEN
		TextL1 := TL_Fault;
	ELSE
		TextL1 := TL_LoadTest;
	END_IF
	Val1 := DWORD_TO_WORD(DW_ElevatorCycles - DW_LoadTestCycle);
	TextL2 := TL_Blank;
	TextL3 := TL_Blank;
	TextL4 := TL_Blank;

	LEDUP := TRUE;
	LEDDOWN := TRUE;
	LEDLEFT := TRUE;
	LEDRIGHT := TRUE;
	LEDOK := FALSE;
	LEDESC := TRUE;
	LEDF1 := TRUE;
	LEDF2 := TRUE;
	LEDF3 := TRUE;
	LEDF4 := TRUE;
	LEDF5 := TRUE;
	LEDF6 := TRUE;
	LEDF7 := TRUE;
	LEDF8 := TRUE;

	OpElevUpFastCmd := KEY_UP_IN AND F1_IN;
	OpElevDownFastCmd := KEY_DOWN_IN AND F1_IN;

	OpBridgeUpFastCmd := KEY_UP_IN AND F2_IN;
	OpBridgeDownFastCmd := KEY_DOWN_IN AND F2_IN;
	OpBridgeUpCmd := KEY_UP_IN AND F2_IN;
	OpBridgeDownCmd := KEY_DOWN_IN AND F2_IN;

	OpBridgeFwdCmd  := KEY_UP_IN AND F3_IN;
	OpBridgeRevCmd  := KEY_DOWN_IN AND F3_IN;
	OpBridgeLeftCmd  := KEY_LEFT_IN AND F3_IN AND OPT_BridgeSS;
	OpBridgeRightCmd  := KEY_RIGHT_IN AND F3_IN AND OPT_BridgeSS;

	OpElevFrontFwdCmd  := KEY_UP_IN AND F4_IN AND NOT F7_IN AND NOT F8_IN;
	OpElevFrontRevCmd  := KEY_DOWN_IN AND F4_IN AND NOT F7_IN AND NOT F8_IN;
	OpElevFrontLeftCmd  := KEY_LEFT_IN AND F4_IN;
	OpElevFrontRightCmd  := KEY_RIGHT_IN AND F4_IN;

	OpElevRearFwdCmd  := KEY_UP_IN AND F5_IN AND NOT F7_IN AND NOT F8_IN;
	OpElevRearRevCmd  := KEY_DOWN_IN AND F5_IN AND NOT F7_IN AND NOT F8_IN;
	OpElevRearLeftCmd  := KEY_LEFT_IN AND F5_IN;
	OpElevRearRightCmd  := KEY_RIGHT_IN AND F5_IN;

	IF KEY_UP_IN AND F7_IN AND NOT F1_IN AND NOT F2_IN THEN
		OpLeftSideGuideUpCmd := TRUE;
	END_IF

	IF KEY_DOWN_IN AND F7_IN AND NOT F1_IN AND NOT F2_IN THEN
		OpLeftSideGuideUpCmd := FALSE;
	END_IF

	IF KEY_UP_IN AND F8_IN AND NOT F1_IN AND NOT F2_IN THEN
		OpRightSideGuideUpCmd := TRUE;
	END_IF

	IF KEY_DOWN_IN AND F8_IN AND NOT F1_IN AND NOT F2_IN THEN
		OpRightSideGuideUpCmd := FALSE;
	END_IF

	OpRearWheelUpCmd := KEY_UP_IN AND F6_IN;
	OpRearWheelDownCmd := KEY_DOWN_IN AND F6_IN;

	IF KEY_ESC THEN
		page_extern := 2; (*Main Menu*)
		B_LoadTestOK := FALSE;
	END_IF
END_IF
END_ACTION

ACTION	Options:
LEDUP := TRUE;
LEDDOWN := TRUE;
LEDLEFT := FALSE;
LEDRIGHT := FALSE;
LEDESC := FALSE;
LEDOK := TRUE;
B_InvisibleValue1 := FALSE;
B_InvisibleValue2 := FALSE;
B_InvisibleValue3 := FALSE;
B_InvisibleValue4 := FALSE;

ScanIndexMax := 80;

IF KEY_UP THEN
	IF SelectedLine = 0 THEN
		IF ScanIndexPointer > 0 THEN
			ScanIndexPointer := ScanIndexPointer - 1;
		ELSE
			ScanIndexPointer := 0;
		END_IF
	ELSE
		SelectedLine := SelectedLine - 1;
	END_IF
END_IF

	IF KEY_DOWN THEN
		IF SelectedLine = MaxLines -1 THEN
			IF ScanIndexPointer < ScanIndexMax - 3 THEN
				ScanIndexPointer := ScanIndexPointer + 1;
			ELSE
				ScanIndexPointer := ScanIndexMax - 3;
			END_IF
		ELSE
			SelectedLine := SelectedLine + 1;
		END_IF
	END_IF

	IF KEY_LEFT THEN
		IF ScanIndexPointer > MaxLines - 1 THEN
			ScanIndexPointer := ScanIndexPointer - MaxLines;
		ELSE
			ScanIndexPointer := 0;
		END_IF
	END_IF

	IF KEY_RIGHT THEN
		IF (ScanIndexPointer < ScanIndexMax - MaxLines - MaxLines + 1) AND NOT (ScanIndexMax < 2*MaxLines) THEN
			ScanIndexPointer := ScanIndexPointer + MaxLines;
		ELSE
			ScanIndexPointer := ScanIndexMax - MaxLines + 1;
		END_IF
	END_IF

	(* System variables list, display the right values *)
	index := 0;
	BY_CurrentLine := 0;
	WHILE index <= 90 AND ScanIndexPointer + 4 > BY_CurrentLine DO
		B_SkipLine := FALSE;
		B_TmpVal := FALSE;
		CASE index OF
		1:
			IF OPT_838STD THEN
				TextTemp := TL_838STD;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_838STD := FALSE;
					OPT_838WID := TRUE;
				END_IF
			ELSIF OPT_838WID THEN
				TextTemp := TL_838WID;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_838WID := FALSE;
					OPT_838UNI := TRUE;
				END_IF
			ELSIF OPT_838UNI THEN
				TextTemp := TL_838UNI;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_838UNI := FALSE;
					OPT_838SUP := TRUE;
				END_IF
			ELSIF OPT_838SUP THEN
				TextTemp := TL_838SUP;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_929 := TRUE;
					OPT_838SUP := FALSE;
				END_IF
			ELSIF OPT_929 THEN
				TextTemp := TL_929;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_929 := FALSE;
					OPT_929S := TRUE;
				END_IF
			ELSIF OPT_929S THEN
				TextTemp := TL_929S;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_929S := FALSE;
					OPT_929H := TRUE;
				END_IF
			ELSIF OPT_929H THEN
				TextTemp := TL_929H;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_929H := FALSE;
					OPT_838STD := TRUE;
				END_IF
			ELSE
				OPT_838STD := TRUE;
			END_IF
			B_TmpVal := TRUE;

		9:
			TextTemp := TL_ElevatorLiftJoystick;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ElevatorLiftJoystick := NOT OPT_ElevatorLiftJoystick;
			END_IF
			B_TmpVal := OPT_ElevatorLiftJoystick;

		10:
			TextTemp := TL_BridgeLiftJoystick;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BridgeLiftJoystick := NOT OPT_BridgeLiftJoystick;
			END_IF
			B_TmpVal := OPT_BridgeLiftJoystick;

		11:
			TextTemp := TL_DeluxeJoystick;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DeluxeJoysticks := NOT OPT_DeluxeJoysticks;
			END_IF
			B_TmpVal := OPT_DeluxeJoysticks;

		12:
			TextTemp := TL_ElevatorDualRotate;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ElevatorDualRotate := NOT OPT_ElevatorDualRotate;
			END_IF
			B_TmpVal := OPT_ElevatorDualRotate;

		13:
			TextTemp := TL_DriveJoystick;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DriveJoystick := NOT OPT_DriveJoystick;
			END_IF
			B_TmpVal := OPT_DriveJoystick;

		14:
			IF OPT_Battery = 0 THEN
				TextTemp :=  TL_LeadAcidBattery;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_Battery := 1;
					IF OPT_838STD OR OPT_838WID OR OPT_838SUP OR OPT_838UNI THEN
						MAX_Battery_Current := 500;
					ELSIF OPT_929 OR OPT_929S OR OPT_929H THEN
						MAX_Battery_Current := 1200;
					END_IF
				END_IF
			ELSIF OPT_Battery = 1 THEN
				TextTemp := TL_GreenCubeBattery;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_Battery := 2;
					IF OPT_838STD OR OPT_838WID OR OPT_838SUP OR OPT_838UNI THEN
						MAX_Battery_Current := 500;
					ELSIF OPT_929 OR OPT_929S OR OPT_929H THEN
						MAX_Battery_Current := 1200;
					END_IF
				END_IF
			ELSIF OPT_Battery = 2 THEN
				TextTemp := TL_TLDiBSBattery;
				IF KEY_OK AND W_SelectedIndex = index THEN
					OPT_Battery := 0;
					IF OPT_838STD OR OPT_838WID OR OPT_838SUP OR OPT_838UNI THEN
						MAX_Battery_Current := 300;
					ELSIF OPT_929 OR OPT_929S OR OPT_929H THEN
						MAX_Battery_Current := 1200;
					END_IF
				END_IF
			ELSE
				OPT_Battery := 0;
			END_IF
			B_TmpVal := TRUE;

		16:
			TextTemp := TL_ASD;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ASD := NOT OPT_ASD;
			END_IF
			B_TmpVal := OPT_ASD;

		17:
			TextTemp := TL_ASDConsignment;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_CONSIGNMENT := NOT OPT_CONSIGNMENT;
			END_IF
			B_TmpVal := OPT_CONSIGNMENT;

		18:
			TextTemp := TL_HandrailSensitiveBumper;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_HandrailSensBump := NOT OPT_HandrailSensBump;
			END_IF
			B_TmpVal := OPT_HandrailSensBump;

		19:
			TextTemp := TL_NoASDButton;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_NOASDButton := NOT OPT_NOASDButton;
			END_IF
			B_TmpVal := OPT_NOASDButton;

		20:
			TextTemp := TL_AutoASDBridgeUp;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_AutoASDBridgeUp := NOT OPT_AutoASDBridgeUp;
			END_IF
			B_TmpVal := OPT_AutoASDBridgeUp;

		21:
			TextTemp := TL_ASDPlus;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ASDPlus := NOT OPT_ASDPlus;
			END_IF
			B_TmpVal := OPT_ASDPlus;

		23:
			TextTemp := TL_AnalogTempSensor;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_AnalogTempSensor := NOT OPT_AnalogTempSensor;
			END_IF
			B_TmpVal := OPT_AnalogTempSensor;

		30:
			TextTemp := TL_BridgeSideShift;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BridgeSS := NOT OPT_BridgeSS;
			END_IF
			B_TmpVal := OPT_BridgeSS;

		33:
			TextTemp := TL_SlowBridgeOnCargo;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_SlowBridgeOnCargo := NOT OPT_SlowBridgeOnCargo;
			END_IF
			B_TmpVal := OPT_SlowBridgeOnCargo;

		36:
			TextTemp := TL_PoweredTrays;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_PwrTrays := NOT OPT_PwrTrays;
			END_IF
			B_TmpVal := OPT_PwrTrays;

		37:
			TextTemp := TL_DeadmanJoystick;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DeadmanJoystick := NOT OPT_DeadmanJoystick;
			END_IF
			B_TmpVal := OPT_DeadmanJoystick;

		40:
			TextTemp := TL_LowHydraulicOilLevelShutdown;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_LowHydShutdown := NOT OPT_LowHydShutdown;
			END_IF
			B_TmpVal := OPT_LowHydShutdown;

		41:
			TextTemp := TL_LowHydraulicOilPressureShutdown;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_HydOilLowPressure := NOT OPT_HydOilLowPressure;
			END_IF
			B_TmpVal := OPT_HydOilLowPressure;

		42:
			TextTemp := TL_TLDLink;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_TLDLink := NOT OPT_TLDLink;
			END_IF
			B_TmpVal := OPT_TLDLink;

		43:
			TextTemp := TL_60Interlock;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_60InIntlk := NOT OPT_60InIntlk;
			END_IF
			B_TmpVal := OPT_60InIntlk;

		45:
			TextTemp := TL_AlternateSlowStop;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_AltSlowStop := NOT OPT_AltSlowStop;
			END_IF
			B_TmpVal := OPT_AltSlowStop;

		47:
			TextTemp := TL_BridgeRearBarrier;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BridgeRearBarrier := NOT OPT_BridgeRearBarrier;
			END_IF
			B_TmpVal := OPT_BridgeRearBarrier;

		48:
			TextTemp := TL_MoveableConsoleDriveInterlock;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_PwrConsoleWalkway := NOT OPT_PwrConsoleWalkway;
			END_IF
			B_TmpVal := OPT_PwrConsoleWalkway;

		49:
			TextTemp := TL_LowBatteryBeacon;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_LowBatteryBeacon := NOT OPT_LowBatteryBeacon;
			END_IF
			B_TmpVal := OPT_LowBatteryBeacon;

		50:
			TextTemp :=  TL_OilRecirculation;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_OilRecirculation := NOT OPT_OilRecirculation;
			END_IF
			B_TmpVal := OPT_OilRecirculation;


		53:
			TextTemp := TL_BridgeAutolevel;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BridgeAutolevel := NOT OPT_BridgeAutolevel;
			END_IF
			B_TmpVal := OPT_BridgeAutolevel;

		54:
			TextTemp := TL_MarkerLights;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_MarkerLights := NOT OPT_MarkerLights;
			END_IF
			B_TmpVal := OPT_MarkerLights;

		55:
			TextTemp := TL_DisableFaultIndicator;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DisableFaultIndicator := NOT OPT_DisableFaultIndicator;
			END_IF
			B_TmpVal := OPT_DisableFaultIndicator;

		56:
			TextTemp := TL_SideGuidesInterlock;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_SideGuidesIntlk := NOT OPT_SideGuidesIntlk;
			END_IF
			B_TmpVal := OPT_SideGuidesIntlk;

		57:
			TextTemp := TL_SensitiveSideGuides;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_SensitiveSideGuidesIntlk := NOT OPT_SensitiveSideGuidesIntlk;
			END_IF
			B_TmpVal := OPT_SensitiveSideGuidesIntlk;

		58:
			TextTemp := TL_BridgeAlarm;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BridgeAlarm := NOT OPT_BridgeAlarm;
			END_IF
			B_TmpVal := OPT_BridgeAlarm;


		59:
			TextTemp := TL_AircraftDetect;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_AircraftDetect := NOT OPT_AircraftDetect;
			END_IF
			B_TmpVal := OPT_AircraftDetect;


		60:
			TextTemp := TL_BridgeSecurity;
			IF KEY_OK AND (F6_IN OR NOT OPT_BridgeSafetySensor) AND W_SelectedIndex = index THEN
				OPT_BridgeSafetySensor := NOT OPT_BridgeSafetySensor;
			END_IF
			B_TmpVal := OPT_BridgeSafetySensor;

		61:
			TextTemp := TL_RHS110Tray;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_RHS110Tray := NOT OPT_RHS110Tray;
			END_IF
			B_TmpVal := OPT_RHS110Tray;

		63:
			TextTemp := TL_UnderBridgeBeacon;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_UnderBridgeBeacon := NOT OPT_UnderBridgeBeacon;
			END_IF
			B_TmpVal := OPT_UnderBridgeBeacon;

		65:
			TextTemp := TL_AllGuidesDown;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_AllGuidesDown := NOT OPT_AllGuidesDown;
			END_IF
			B_TmpVal := OPT_AllGuidesDown;

		67:
			TextTemp := TL_Tray145;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_Tray145 := NOT OPT_Tray145;
			END_IF
			B_TmpVal := OPT_Tray145;

		68:
			TextTemp := TL_NoStabilizersAlarm;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_NoStabAlarm := NOT OPT_NoStabAlarm;
			END_IF
			B_TmpVal := OPT_NoStabAlarm;

		69:
			TextTemp := TL_UnderElevatorBeacon;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_UnderElevBeacon := NOT OPT_UnderElevBeacon;
			END_IF
			B_TmpVal := OPT_UnderElevBeacon;

		70:
			TextTemp := TL_SensitiveBumper;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_SensitiveBumper := NOT OPT_SensitiveBumper;
			END_IF
			B_TmpVal := OPT_SensitiveBumper;

		71:
			TextTemp := TL_ChassisRearHorn;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ChassisRearHorn := NOT OPT_ChassisRearHorn;
			END_IF
			B_TmpVal := OPT_ChassisRearHorn;

		72:
			TextTemp :=  TL_DriveReverseInhibit;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DriveRevInhibitWithBridgeUp := NOT OPT_DriveRevInhibitWithBridgeUp;
			END_IF
			B_TmpVal := OPT_DriveRevInhibitWithBridgeUp;

		75:
			TextTemp :=  TL_LowHydraulicOilLevelIndicator;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_LowHydOilLevelIndicator := NOT OPT_LowHydOilLevelIndicator;
			END_IF
			B_TmpVal := OPT_LowHydOilLevelIndicator;


		78:
			TextTemp := TL_NoRestartOnFault;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_NoRestartOnFault := NOT OPT_NoRestartOnFault;
			END_IF
			B_TmpVal := OPT_NoRestartOnFault;

		79:
			TextTemp :=  TL_ZeroStraddleDetection;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_StraddleDetect := NOT OPT_StraddleDetect;
			END_IF
			B_TmpVal := OPT_StraddleDetect;

		80:
			TextTemp := TL_InwardSideRollers;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_InwardSideRollers := NOT OPT_InwardSideRollers;
			END_IF
			B_TmpVal := OPT_InwardSideRollers;

		81:
			TextTemp := TL_NoRearWheelAlarm;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_NoRearWheelsAlarm := NOT OPT_NoRearWheelsAlarm;
			END_IF
			B_TmpVal := OPT_NoRearWheelsAlarm;

		84:
			TextTemp := TL_DCDCSystem;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DCDCSystem := NOT OPT_DCDCSystem;
			END_IF
			B_TmpVal := OPT_DCDCSystem;

		85:
			TextTemp := TL_ManLift;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_ManLift := NOT OPT_ManLift;
			END_IF
			B_TmpVal := OPT_ManLift;

		86:
			TextTemp := TL_LHS110Tray;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_LHS110Tray := NOT OPT_LHS110Tray;
			END_IF
			B_TmpVal := OPT_LHS110Tray;

		87:
			TextTemp := TL_DriveAlarm;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_DriveAlarm := NOT OPT_DriveAlarm;
			END_IF
			B_TmpVal := OPT_DriveAlarm;

		89:
			TextTemp := TL_BatteryInterlock;
			IF KEY_OK AND W_SelectedIndex = index THEN
				OPT_BatteryLevelInterlock := NOT OPT_BatteryLevelInterlock;
			END_IF
			B_TmpVal := OPT_BatteryLevelInterlock;

		ELSE
			B_SkipLine := TRUE;
		END_CASE

		(* Shift lines to be displayed *)
		IF NOT B_SkipLine THEN
			TextL1 := TextL2;
			Val1 := Val2;
			TextL2 := TextL3;
			Val2 := Val3;
			TextL3 := TextL4;
			Val3 := Val4;
			TextL4 := TextTemp;
			Val4 := BOOL_TO_WORD(B_TmpVal);

			W_DisplayedIndex[0] := W_DisplayedIndex[1];
			W_DisplayedIndex[1] := W_DisplayedIndex[2];
			W_DisplayedIndex[2] := W_DisplayedIndex[3];
			W_DisplayedIndex[3] := index;

			BY_CurrentLine := BY_CurrentLine + 1;
		END_IF

		(* Increment index until last line *)
		index := index + 1;
	END_WHILE

	IF ScanIndexPointer + 4 > BY_CurrentLine THEN
		ScanIndexPointer := ScanIndexPointer - 1;
	END_IF

	W_SelectedIndex := W_DisplayedIndex[SelectedLine];

	IF SelectedLine = 0 THEN
		FrameColorL1 := TRUE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 1 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := TRUE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 2 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := TRUE;
		FrameColorL4 := FALSE;
	ELSIF SelectedLine = 3 THEN
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := TRUE;
	ELSE
		FrameColorL1 := FALSE;
		FrameColorL2 := FALSE;
		FrameColorL3 := FALSE;
		FrameColorL4 := FALSE;
	END_IF

END_ACTION

